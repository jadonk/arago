From 969c4676a546aaf16501372ecdcdb9998d8a1cc6 Mon Sep 17 00:00:00 2001
From: Sriram <srk@ti.com>
Date: Fri, 5 Sep 2008 13:54:42 +0530
Subject: [PATCH 11/24] OMAP35x : Add support BT656 Capture interface.

---
 arch/arm/mach-omap2/Kconfig              |    6 +-
 arch/arm/mach-omap2/Makefile             |    1 +
 arch/arm/mach-omap2/board-omap3evm-dc.c  |  780 ++++++++++++++++++
 arch/arm/mach-omap2/board-omap3evm-dc.h  |   49 ++
 arch/arm/mach-omap2/io.c                 |   12 +-
 arch/arm/mm/mmu.c                        |    7 +-
 drivers/media/video/Kconfig              |   11 +
 drivers/media/video/Makefile             |    1 +
 drivers/media/video/isp/Kconfig          |    5 +
 drivers/media/video/isp/Makefile         |    6 +-
 drivers/media/video/isp/isp.c            |  420 ++++++++--
 drivers/media/video/isp/isp.h            |   19 +-
 drivers/media/video/isp/isp_af.c         |  812 ++++++++++++++++++
 drivers/media/video/isp/isp_af.h         |  141 ++++
 drivers/media/video/isp/ispccdc.c        |  142 +++-
 drivers/media/video/isp/ispccdc.h        |   13 +
 drivers/media/video/isp/isph3a.c         |   13 +-
 drivers/media/video/isp/isph3a.h         |    5 +-
 drivers/media/video/isp/isphist.c        |   17 +-
 drivers/media/video/isp/isphist.h        |    5 +-
 drivers/media/video/isp/ispmmu.c         |   11 +-
 drivers/media/video/isp/ispmmu.h         |    4 +
 drivers/media/video/isp/isppreview.c     |   30 +-
 drivers/media/video/isp/isppreview.h     |    7 +-
 drivers/media/video/isp/ispresizer.c     |   15 +-
 drivers/media/video/isp/ispresizer.h     |    4 +
 drivers/media/video/isp/omap_previewer.c |    5 +-
 drivers/media/video/omap34xxcam.c        |  493 ++++++++----
 drivers/media/video/omap34xxcam.h        |    4 +
 drivers/media/video/tvp5146.c            | 1319 ++++++++++++++++++++++++++++++
 drivers/media/video/tvp5146.h            |  404 +++++++++
 drivers/media/video/v4l2-int-device.c    |    5 +-
 include/asm-arm/arch-omap/isp_user.h     |  114 +++
 include/asm-arm/mach/map.h               |    1 +
 include/media/v4l2-int-device.h          |   18 +
 35 files changed, 4593 insertions(+), 306 deletions(-)
 create mode 100644 arch/arm/mach-omap2/board-omap3evm-dc.c
 create mode 100644 arch/arm/mach-omap2/board-omap3evm-dc.h
 create mode 100644 drivers/media/video/isp/isp_af.c
 create mode 100644 drivers/media/video/isp/isp_af.h
 create mode 100644 drivers/media/video/tvp5146.c
 create mode 100644 drivers/media/video/tvp5146.h

diff --git a/arch/arm/mach-omap2/Kconfig b/arch/arm/mach-omap2/Kconfig
index 73e0726..bf08748 100644
--- a/arch/arm/mach-omap2/Kconfig
+++ b/arch/arm/mach-omap2/Kconfig
@@ -155,7 +155,7 @@ config MACH_OMAP_LDP
 	bool "OMAP 3 LDP board"
 	depends on ARCH_OMAP3 && ARCH_OMAP34XX
 
-config MACH_OMAP2EVM 
+config MACH_OMAP2EVM
 	bool "OMAP 2530 EVM board"
 	depends on ARCH_OMAP2 && ARCH_OMAP24XX
 
@@ -167,6 +167,10 @@ config MACH_OMAP3EVM
 	bool "OMAP 3530 EVM board"
 	depends on ARCH_OMAP35XX
 
+config MACH_OMAP3EVM_DC
+	bool "OMAP 3530 EVM daughter card board"
+	depends on ARCH_OMAP3 && ARCH_OMAP34XX && MACH_OMAP3EVM
+
 config MACH_OMAP3_BEAGLE
 	bool "OMAP3 BEAGLE board"
 	depends on ARCH_OMAP3 && ARCH_OMAP34XX
diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
index 16b3679..014483a 100644
--- a/arch/arm/mach-omap2/Makefile
+++ b/arch/arm/mach-omap2/Makefile
@@ -61,6 +61,7 @@ obj-$(CONFIG_MACH_OMAP3EVM)		+= board-omap3evm.o \
 					   hsmmc.o \
 					   usb-musb.o usb-ehci.o \
 					   board-omap3evm-flash.o
+obj-$(CONFIG_MACH_OMAP3EVM_DC)		+= board-omap3evm-dc.o
 obj-$(CONFIG_MACH_OMAP3_BEAGLE)		+= board-omap3beagle.o \
 					   usb-musb.o usb-ehci.o \
 					   hsmmc.o
diff --git a/arch/arm/mach-omap2/board-omap3evm-dc.c b/arch/arm/mach-omap2/board-omap3evm-dc.c
new file mode 100644
index 0000000..dd89d1b
--- /dev/null
+++ b/arch/arm/mach-omap2/board-omap3evm-dc.c
@@ -0,0 +1,780 @@
+/*
+ * arch/arm/mach-omap2/board-omap3evm-dc.c
+ *
+ * Driver for OMAP3 EVM Daughter Card
+ *
+ * Copyright (C) 2008 Texas Instruments Inc
+ *
+ * Contributors:
+ *     Anuj Aggarwal <anuj.aggarwal@ti.com>
+ *     Sivaraj R <sivaraj@ti.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel_stat.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/io.h>
+
+#include <asm/arch/io.h>
+#include <asm/arch/gpmc.h>
+
+#if defined(CONFIG_VIDEO_TVP5146) || defined(CONFIG_VIDEO_TVP5146_MODULE)
+#include <linux/videodev2.h>
+#include <media/v4l2-int-device.h>
+#include <../drivers/media/video/tvp5146.h>
+
+#if defined(CONFIG_VIDEO_OMAP3_CAMERA) \
+	|| defined(CONFIG_VIDEO_OMAP3_CAMERA_MODULE)
+#include <../drivers/media/video/omap34xxcam.h>
+#include <../drivers/media/video/isp/ispreg.h>
+#endif				/* #ifdef CONFIG_VIDEO_OMAP3_CAMERA */
+
+#endif				/* #ifdef CONFIG_VIDEO_TVP5146 */
+
+#include "board-omap3evm-dc.h"
+
+#define MODULE_NAME			"omap3evmdc"
+
+#ifdef DEBUG
+#define dprintk(fmt, args...) printk(KERN_ERR MODULE_NAME ": " fmt, ## args)
+#else
+#define dprintk(fmt, args...)
+#endif				/* #ifdef DEBUG */
+
+/* Macro Definitions */
+
+/* System control module register offsets */
+#define REG_CONTROL_PADCONF_GPMC_NCS3	(0x480020B4u)
+#define REG_CONTROL_PADCONF_I2C2_SDA	(0x480021C0u)
+#define REG_CONTROL_PADCONF_I2C3_SDA	(0x480021C4u)
+
+#define PADCONF_I2C3_SCL_MASK		(0xFFFF0000u)
+#define PADCONF_I2C3_SDA_MASK		(0x0000FFFFu)
+#define PADCONF_GPMC_NCS4_MASK		(0xFFFF0000u)
+
+/* mux mode 0 (enable I2C3 SCL), pull-up enable, input enable */
+#define PADCONF_I2C3_SCL_DEF		(0x01180000u)
+/* mux mode 0 (enable I2C3 SDA), pull-up enable, input enable */
+#define PADCONF_I2C3_SDA_DEF		(0x00000118u)
+/* mux mode 0 (enable GPMC CS4), pull-up enable */
+#define PADCONF_GPMC_NCS4_DEF		(0x00180000u)
+
+/* board internal information (BEGIN) */
+
+/* GPMC chip select used in board */
+#define BOARD_GPMC_CS			(4)
+/* I2C bus to which all I2C slave devices are attached */
+#define BOARD_I2C_BUSNUM		(3)
+
+/* I2C address of chips present in board */
+#define TVP5146_I2C_ADDR		(0x5D)
+
+/* Register offsets */
+#define REG_MLC_NCS0			(0x00000000u)
+#define REG_MLC_NCS1			(0x00000040u)
+#define REG_F_ACSN			(0x00000080u)
+#define REG_F_SCSN			(0x000000C0u)
+#define REG_PATA_NCS			(0x00000100u)
+#define REG_BUS_CTRL1			(0x00000180u)
+#define REG_BUS_CTRL2			(0x000001C0u)
+
+/* Bit defines for Bus Control 1 register */
+#define TVP5146_EN_SHIFT		(0x0000u)
+#define TVP5146_EN_MASK			(1u << TVP5146_EN_SHIFT)
+
+#define MCBSP2_EN_SHIFT			(0x0001u)
+#define MCBSP2_EN_MASK			(0x0006u)	/* two bits used */
+#define MCBSP2_DISCONNECT_BIT		(0x0000u)
+#define MCBSP2_AIC23_EN_BIT		(0x0001u)
+#define MCBSP2_SPDIF_EN_BIT		(0x0002u)
+#define MCBSP2_HDMI_EN_BIT		(0x0003u)
+
+#define BT_MCBSP3_EN_SHIFT		(0x0003u)
+#define BT_MCBSP3_EN_MASK		(1u << BT_MCBSP3_EN_SHIFT)
+
+#define JAC_MCSPI2_EN_SHIFT		(0x0004u)
+#define JAC_MCSPI2_EN_MASK		(1u << JAC_MCSPI2_EN_SHIFT)
+
+#define BT_UART1_EN_SHIFT		(0x0005u)
+#define BT_UART1_EN_MASK		(1u << BT_UART1_EN_SHIFT)
+
+#define MLC_NAND_EN_SHIFT		(0x0006u)
+#define MLC_NAND_EN_MASK		(1u << MLC_NAND_EN_SHIFT)
+
+#define JAC_MCBSP1_EN_SHIFT		(0x0007u)
+#define JAC_MCBSP1_EN_MASK		(1u << JAC_MCBSP1_EN_SHIFT)
+
+#define IMAGE_SENSOR_EN_SHIFT		(0x0008u)
+#define IMAGE_SENSOR_EN_MASK		(1u << IMAGE_SENSOR_EN_SHIFT)
+
+#define JAC_MCBSP3_EN_SHIFT		(0x0009u)
+#define JAC_MCBSP3_EN_MASK		(1u << JAC_MCBSP3_EN_SHIFT)
+
+#define SPDIF_MCSPI2_EN_SHIFT		(0x000Au)
+#define SPDIF_MCSPI2_EN_MASK		(1u << SPDIF_MCSPI2_EN_SHIFT)
+
+/* default value for bus control registers */
+#define BUS_CONTROL1_DEF		(0x0141u)	/* Disable all mux */
+#define BUS_CONTROL2_DEF		(0x010Au)	/* Disable all mux */
+
+/* board internal information (END) */
+
+/**
+ * struct gpmc_info -  Structure to store GPMC information.
+ * @gpmc_phy_base - GPMC device physical base address.
+ * @gpmc_vir_base - GPMC device virtual base address.
+ * @bus_control1 - Bus control register 1.
+ * @bus_control2 - Bus control register 2.
+ * @reg_lock - To lock access to GPMC bus control registers.
+ */
+struct gpmc_info {
+	u32 *gpmc_phy_base;
+	u32 *gpmc_vir_base;
+
+	u16 bus_control1;
+	u16 bus_control2;
+
+	spinlock_t reg_lock;
+};
+static struct gpmc_info gpmc_handle;
+
+/**
+ * @brief write_gpmc_reg - writes to registers through GPMC.
+ *
+ * @param val - value to write
+ * @param reg - register offset
+ *
+ * @note bus control registers are write only registers. Hence the values are
+ *       updated locally in variables and are used when they are read.
+ */
+static inline void write_gpmc_reg(u16 val, u32 reg)
+{
+	if (reg == REG_BUS_CTRL1)
+		gpmc_handle.bus_control1 = val;
+	else if (reg == REG_BUS_CTRL2)
+		gpmc_handle.bus_control2 = val;
+
+	__raw_writew(val, ((u32) gpmc_handle.gpmc_vir_base + reg));
+}
+
+/**
+ * @brief read_gpmc_reg - read register value
+ *
+ * @param reg - register offset
+ * @return register value
+ *
+ * @note bus control registers are write only registers. Hence the values are
+ *       updated locally in variables and are used when they are read.
+ *       Read access to other registers are unknown and hence GPMC read
+ *       operation is performed as is.
+ */
+static inline u16 read_gpmc_reg(u32 reg)
+{
+	if (reg == REG_BUS_CTRL1)
+		return gpmc_handle.bus_control1;
+	else if (reg == REG_BUS_CTRL2)
+		return gpmc_handle.bus_control2;
+	else
+		return __raw_readw((u32) gpmc_handle.gpmc_vir_base + reg);
+}
+
+/**
+ * @brief omap3evmdc_set_mux - Sets mux to enable/disable signal routing to
+ *                             different peripherals present in board
+ * IMPORTANT - This function will take care of writing appropriate values for
+ * active low signals as well
+ *
+ * @param mux_id - enum, mux id to enable/disable
+ * @param value - enum, ENABLE_MUX for enabling and DISABLE_MUX for disabling
+ *
+ * @return result of operation - 0 is success
+ */
+int omap3evmdc_set_mux(enum omap3evmdc_mux mux_id, enum config_mux value)
+{
+	int err = 0;
+	u16 bus_ctrl;
+	unsigned long flags;
+
+	if (unlikely(mux_id >= NUM_MUX)) {
+		dprintk("Invalid mux id\n");
+		return -EPERM;
+	}
+
+	spin_lock_irqsave(&gpmc_handle.reg_lock, flags);
+
+	switch (mux_id) {
+	case MUX_TVP5146:
+		bus_ctrl = read_gpmc_reg(REG_BUS_CTRL1);
+		bus_ctrl &= ~TVP5146_EN_MASK;
+
+		/* active low signal. set 0 to enable, 1 to disable */
+		if (DISABLE_MUX == value)
+			bus_ctrl |= (1 << TVP5146_EN_SHIFT);
+
+		write_gpmc_reg(bus_ctrl, REG_BUS_CTRL1);
+		break;
+
+	case MUX_AIC23_MCBSP2:
+		bus_ctrl = read_gpmc_reg(REG_BUS_CTRL1);
+		bus_ctrl &= ~MCBSP2_EN_MASK;
+
+		/* active high signal. set 1 to enable, 0 to disable */
+		if (ENABLE_MUX == value)
+			bus_ctrl |=
+			    (MCBSP2_AIC23_EN_BIT << MCBSP2_EN_SHIFT);
+
+		write_gpmc_reg(bus_ctrl, REG_BUS_CTRL1);
+		break;
+
+	case MUX_SPDIF_MCBSP2:
+		bus_ctrl = read_gpmc_reg(REG_BUS_CTRL1);
+		bus_ctrl &= ~MCBSP2_EN_MASK;
+
+		/* active high signal. set 1 to enable, 0 to disable */
+		if (ENABLE_MUX == value)
+			bus_ctrl |=
+			    (MCBSP2_SPDIF_EN_BIT << MCBSP2_EN_SHIFT);
+
+		write_gpmc_reg(bus_ctrl, REG_BUS_CTRL1);
+		break;
+
+	case MUX_HDMI_MCBSP2:
+		bus_ctrl = read_gpmc_reg(REG_BUS_CTRL1);
+		bus_ctrl &= ~MCBSP2_EN_MASK;
+
+		/* active high signal. set 1 to enable, 0 to disable */
+		if (ENABLE_MUX == value)
+			bus_ctrl |=
+			    (MCBSP2_HDMI_EN_BIT << MCBSP2_EN_SHIFT);
+
+		write_gpmc_reg(bus_ctrl, REG_BUS_CTRL1);
+		break;
+
+	case MUX_BT_MCBSP3:
+		bus_ctrl = read_gpmc_reg(REG_BUS_CTRL1);
+		bus_ctrl &= ~BT_MCBSP3_EN_MASK;
+
+		/* active high signal. set 1 to enable, 0 to disable */
+		if (ENABLE_MUX == value)
+			bus_ctrl |= (1 << BT_MCBSP3_EN_SHIFT);
+
+		write_gpmc_reg(bus_ctrl, REG_BUS_CTRL1);
+		break;
+
+	case MUX_JAC_MCSPI2:
+		bus_ctrl = read_gpmc_reg(REG_BUS_CTRL1);
+		bus_ctrl &= ~JAC_MCSPI2_EN_MASK;
+
+		/* active high signal. set 1 to enable, 0 to disable */
+		if (ENABLE_MUX == value)
+			bus_ctrl |= (1 << JAC_MCSPI2_EN_SHIFT);
+
+		write_gpmc_reg(bus_ctrl, REG_BUS_CTRL1);
+		break;
+
+	case MUX_BT_UART1:
+		bus_ctrl = read_gpmc_reg(REG_BUS_CTRL1);
+		bus_ctrl &= ~BT_UART1_EN_MASK;
+
+		/* active high signal. set 1 to enable, 0 to disable */
+		if (ENABLE_MUX == value)
+			bus_ctrl |= (1 << BT_UART1_EN_SHIFT);
+
+		write_gpmc_reg(bus_ctrl, REG_BUS_CTRL1);
+		break;
+
+	case MUX_MLC_NAND:
+		bus_ctrl = read_gpmc_reg(REG_BUS_CTRL1);
+		bus_ctrl &= ~MLC_NAND_EN_MASK;
+
+		/* active low signal. set 0 to enable, 1 to disable */
+		if (DISABLE_MUX == value)
+			bus_ctrl |= (1 << MLC_NAND_EN_SHIFT);
+
+		write_gpmc_reg(bus_ctrl, REG_BUS_CTRL1);
+		break;
+
+	case MUX_JAC_MCBSP1:
+		bus_ctrl = read_gpmc_reg(REG_BUS_CTRL1);
+		bus_ctrl &= ~JAC_MCBSP1_EN_MASK;
+
+		/* active high signal. set 1 to enable, 0 to disable */
+		if (ENABLE_MUX == value)
+			bus_ctrl |= (1 << JAC_MCBSP1_EN_SHIFT);
+
+		write_gpmc_reg(bus_ctrl, REG_BUS_CTRL1);
+		break;
+
+	case MUX_IMAGE_SENSOR:
+		bus_ctrl = read_gpmc_reg(REG_BUS_CTRL1);
+		bus_ctrl &= ~IMAGE_SENSOR_EN_MASK;
+
+		/* active low signal. set 0 to enable, 1 to disable */
+		if (DISABLE_MUX == value)
+			bus_ctrl |= (1 << IMAGE_SENSOR_EN_SHIFT);
+
+		write_gpmc_reg(bus_ctrl, REG_BUS_CTRL1);
+		break;
+
+	case MUX_JAC_MCBSP3:
+		bus_ctrl = read_gpmc_reg(REG_BUS_CTRL1);
+		bus_ctrl &= ~JAC_MCBSP3_EN_MASK;
+
+		/* active high signal. set 1 to enable, 0 to disable */
+		if (ENABLE_MUX == value)
+			bus_ctrl |= (1 << JAC_MCBSP3_EN_SHIFT);
+
+		write_gpmc_reg(bus_ctrl, REG_BUS_CTRL1);
+		break;
+
+	case MUX_SPDIF_MCSPI2:
+		bus_ctrl = read_gpmc_reg(REG_BUS_CTRL1);
+		bus_ctrl &= ~SPDIF_MCSPI2_EN_MASK;
+
+		/* active high signal. set 1 to enable, 0 to disable */
+		if (ENABLE_MUX == value)
+			bus_ctrl |= (1 << SPDIF_MCSPI2_EN_SHIFT);
+
+		write_gpmc_reg(bus_ctrl, REG_BUS_CTRL1);
+		break;
+
+	case NUM_MUX:
+	default:
+		dprintk("Invalid mux id\n");
+		err = -EPERM;
+	}
+
+	spin_unlock_irqrestore(&gpmc_handle.reg_lock, flags);
+
+	return err;
+}
+EXPORT_SYMBOL(omap3evmdc_set_mux);
+
+#if defined(CONFIG_VIDEO_TVP5146) || defined(CONFIG_VIDEO_TVP5146_MODULE)
+
+/* TVP5146 default register values */
+static struct tvp5146_reg tvp5146_reg_list[] = {
+	{TOK_WRITE, REG_INPUT_SEL, 0x05},	/* Composite selected */
+	{TOK_WRITE, REG_AFE_GAIN_CTRL, 0x0F},
+	{TOK_WRITE, REG_VIDEO_STD, 0x00},	/* Auto mode */
+	{TOK_WRITE, REG_OPERATION_MODE, 0x00},
+	{TOK_SKIP, REG_AUTOSWITCH_MASK, 0x3F},
+	{TOK_WRITE, REG_COLOR_KILLER, 0x10},
+	{TOK_WRITE, REG_LUMA_CONTROL1, 0x00},
+	{TOK_WRITE, REG_LUMA_CONTROL2, 0x00},
+	{TOK_WRITE, REG_LUMA_CONTROL3, 0x02},
+	{TOK_WRITE, REG_BRIGHTNESS, 0x80},
+	{TOK_WRITE, REG_CONTRAST, 0x80},
+	{TOK_WRITE, REG_SATURATION, 0x80},
+	{TOK_WRITE, REG_HUE, 0x00},
+	{TOK_WRITE, REG_CHROMA_CONTROL1, 0x00},
+	{TOK_WRITE, REG_CHROMA_CONTROL2, 0x0E},
+	{TOK_SKIP, 0x0F, 0x00},	/* Reserved */
+	{TOK_WRITE, REG_COMP_PR_SATURATION, 0x80},
+	{TOK_WRITE, REG_COMP_Y_CONTRAST, 0x80},
+	{TOK_WRITE, REG_COMP_PB_SATURATION, 0x80},
+	{TOK_SKIP, 0x13, 0x00},	/* Reserved */
+	{TOK_WRITE, REG_COMP_Y_BRIGHTNESS, 0x80},
+	{TOK_SKIP, 0x15, 0x00},	/* Reserved */
+	{TOK_SKIP, REG_AVID_START_PIXEL_LSB, 0x55},	/* NTSC timing */
+	{TOK_SKIP, REG_AVID_START_PIXEL_MSB, 0x00},
+	{TOK_SKIP, REG_AVID_STOP_PIXEL_LSB, 0x25},
+	{TOK_SKIP, REG_AVID_STOP_PIXEL_MSB, 0x03},
+	{TOK_SKIP, REG_HSYNC_START_PIXEL_LSB, 0x00},	/* NTSC timing */
+	{TOK_SKIP, REG_HSYNC_START_PIXEL_MSB, 0x00},
+	{TOK_SKIP, REG_HSYNC_STOP_PIXEL_LSB, 0x40},
+	{TOK_SKIP, REG_HSYNC_STOP_PIXEL_MSB, 0x00},
+	{TOK_SKIP, REG_VSYNC_START_LINE_LSB, 0x04},	/* NTSC timing */
+	{TOK_SKIP, REG_VSYNC_START_LINE_MSB, 0x00},
+	{TOK_SKIP, REG_VSYNC_STOP_LINE_LSB, 0x07},
+	{TOK_SKIP, REG_VSYNC_STOP_LINE_MSB, 0x00},
+	{TOK_SKIP, REG_VBLK_START_LINE_LSB, 0x01},	/* NTSC timing */
+	{TOK_SKIP, REG_VBLK_START_LINE_MSB, 0x00},
+	{TOK_SKIP, REG_VBLK_STOP_LINE_LSB, 0x15},
+	{TOK_SKIP, REG_VBLK_STOP_LINE_MSB, 0x00},
+	{TOK_SKIP, 0x26, 0x00},	/* Reserved */
+	{TOK_SKIP, 0x27, 0x00},	/* Reserved */
+	{TOK_SKIP, REG_FAST_SWTICH_CONTROL, 0xCC},
+	{TOK_SKIP, 0x29, 0x00},	/* Reserved */
+	{TOK_SKIP, REG_FAST_SWTICH_SCART_DELAY, 0x00},
+	{TOK_SKIP, 0x2B, 0x00},	/* Reserved */
+	{TOK_SKIP, REG_SCART_DELAY, 0x00},
+	{TOK_SKIP, REG_CTI_DELAY, 0x00},
+	{TOK_SKIP, REG_CTI_CONTROL, 0x00},
+	{TOK_SKIP, 0x2F, 0x00},	/* Reserved */
+	{TOK_SKIP, 0x30, 0x00},	/* Reserved */
+	{TOK_SKIP, 0x31, 0x00},	/* Reserved */
+	{TOK_WRITE, REG_SYNC_CONTROL, 0x0C},	/* HS, VS active high */
+	{TOK_WRITE, REG_OUTPUT_FORMATTER1, 0x00},	/* 10-bit BT.656 */
+	{TOK_WRITE, REG_OUTPUT_FORMATTER2, 0x11},	/* Enable clk & data */
+	{TOK_WRITE, REG_OUTPUT_FORMATTER3, 0xEE},	/* Enable AVID & FLD */
+	{TOK_WRITE, REG_OUTPUT_FORMATTER4, 0xAF},	/* Enable VS & HS */
+	{TOK_WRITE, REG_OUTPUT_FORMATTER5, 0xFF},
+	{TOK_WRITE, REG_OUTPUT_FORMATTER6, 0xFF},
+	{TOK_WRITE, REG_CLEAR_LOST_LOCK, 0x01},	/* Clear status */
+	{TOK_TERM, 0, 0}
+};
+
+/* Supported inputs - Composite and S-Video */
+static const struct tvp5146_input_info tvp5146_input_list[] = {
+	{
+	 .input_sel = 0x05,	/* Composite input 2_B */
+	 .lock_mask = 0x0E,	/* Color subcarrier VS & HS lock */
+	 .input = {
+		   .index = 0,
+		   .name = "Vin (Composite)",
+		   .type = V4L2_INPUT_TYPE_CAMERA,
+		   .std = V4L2_STD_NTSC | V4L2_STD_PAL,}
+	 },
+	{
+	 .input_sel = 0x46,	/* S-Video input 2_C(Y), 1_C(C) */
+	 .lock_mask = 0x06,	/* VS & HS lock */
+	 .input = {
+		   .index = 1,
+		   .name = "Vin (S-Video)",
+		   .type = V4L2_INPUT_TYPE_CAMERA,
+		   .std = V4L2_STD_NTSC | V4L2_STD_PAL,}
+	 }
+};
+
+#define TVP5146_NUM_INPUTS		ARRAY_SIZE(tvp5146_input_list)
+
+#if defined(CONFIG_VIDEO_OMAP3_CAMERA) \
+	|| defined(CONFIG_VIDEO_OMAP3_CAMERA_MODULE)
+static struct omap34xxcam_hw_config decoder_hwc = {
+	.dev_index = 0,
+	.dev_minor = 0,
+	.dev_type = OMAP34XXCAM_SLAVE_SENSOR,
+	.u.sensor.xclk = OMAP34XXCAM_XCLK_NONE,
+	.u.sensor.sensor_isp = V4L2_IF_CAP_SOC,
+};
+
+static struct isp_interface_config tvp5146_if_config = {
+	.ccdc_par_ser = ISP_PARLL_YUV_BT,
+	.dataline_shift = 0x2,
+	.hsvs_syncdetect = ISPCTRL_SYNC_DETECT_VSRISE,
+	.vdint0_timing = 0x0,
+	.vdint1_timing = 0x0,
+	.strobe = 0x0,
+	.prestrobe = 0x0,
+	.shutter = 0x0,
+	.u.par.par_bridge = 0x0,
+	.u.par.par_clk_pol = 0x0,
+};
+#endif
+
+static struct v4l2_ifparm ifparm = {
+	.capability = V4L2_IF_CAP_SOC,
+	.if_type = V4L2_IF_TYPE_BT656,
+	.u = {
+	      .bt656 = {
+			.frame_start_on_rising_vs = 1,
+			.bt_sync_correct = 0,
+			.swap = 0,
+			.latch_clk_inv = 0,
+			.nobt_hs_inv = 0,	/* active high */
+			.nobt_vs_inv = 0,	/* active high */
+			.mode = V4L2_IF_TYPE_BT656_MODE_BT_8BIT,
+			.clock_min = TVP5146_XCLK_BT656,
+			.clock_max = TVP5146_XCLK_BT656,
+			},
+	      },
+};
+
+/**
+ * @brief tvp5146_ifparm - Returns the TVP5146 decoder interface parameters
+ *
+ * @param p - pointer to v4l2_ifparm structure
+ *
+ * @return result of operation - 0 is success
+ */
+static int tvp5146_ifparm(struct v4l2_ifparm *p)
+{
+	if (p == NULL)
+		return -EINVAL;
+
+	*p = ifparm;
+	return 0;
+}
+
+/**
+ * @brief tvp5146_set_prv_data - Returns tvp5146 omap34xx driver private data
+ *
+ * @param priv - pointer to omap34xxcam_hw_config structure
+ *
+ * @return result of operation - 0 is success
+ */
+static int tvp5146_set_prv_data(void *priv)
+{
+#if defined(CONFIG_VIDEO_OMAP3_CAMERA) \
+	|| defined(CONFIG_VIDEO_OMAP3_CAMERA_MODULE)
+	struct omap34xxcam_hw_config *hwc = priv;
+
+	if (priv == NULL)
+		return -EINVAL;
+
+	hwc->u.sensor.sensor_isp = decoder_hwc.u.sensor.sensor_isp;
+	hwc->u.sensor.xclk = decoder_hwc.u.sensor.xclk;
+	hwc->dev_index = decoder_hwc.dev_index;
+	hwc->dev_minor = decoder_hwc.dev_minor;
+	hwc->dev_type = decoder_hwc.dev_type;
+	return 0;
+#else
+	return -EINVAL;
+#endif
+}
+
+/**
+ * @brief tvp5146_power_set - Power-on or power-off TVP5146 device
+ *
+ * @param power - enum, Power on/off, resume/standby
+ *
+ * @return result of operation - 0 is success
+ */
+static int tvp5146_power_set(enum v4l2_power power)
+{
+	switch (power) {
+	case V4L2_POWER_OFF:
+#if defined(CONFIG_VIDEO_OMAP3_CAMERA) \
+	|| defined(CONFIG_VIDEO_OMAP3_CAMERA_MODULE)
+		if (isp_free_interface(ISP_PARLL_YUV_BT))
+			return -ENODEV;
+#endif
+
+		/* Disable mux for TVP5146 decoder data path */
+		if (omap3evmdc_set_mux(MUX_TVP5146, DISABLE_MUX))
+			return -ENODEV;
+		break;
+
+	case V4L2_POWER_STANDBY:
+		break;
+
+	case V4L2_POWER_ON:
+#if defined(CONFIG_VIDEO_OMAP3_CAMERA) \
+	|| defined(CONFIG_VIDEO_OMAP3_CAMERA_MODULE)
+		if (isp_request_interface(ISP_PARLL_YUV_BT))
+			return -ENODEV;
+
+		isp_configure_interface(&tvp5146_if_config);
+#endif
+
+		/* Enable mux for TVP5146 decoder data path */
+		if (omap3evmdc_set_mux(MUX_TVP5146, ENABLE_MUX)) {
+#if defined(CONFIG_VIDEO_OMAP3_CAMERA) \
+	|| defined(CONFIG_VIDEO_OMAP3_CAMERA_MODULE)
+			isp_free_interface(ISP_PARLL_YUV_BT);
+#endif
+			return -ENODEV;
+		}
+		break;
+
+	case V4L2_POWER_RESUME:
+		break;
+
+	default:
+		return -ENODEV;
+		break;
+	}
+	return 0;
+}
+
+static struct tvp5146_platform_data tvp5146_pdata = {
+	.power_set = tvp5146_power_set,
+	.priv_data_set = tvp5146_set_prv_data,
+	.ifparm = tvp5146_ifparm,
+
+	/* TVP5146 regsiter list, contains default values */
+	.reg_list = tvp5146_reg_list,
+
+	/* Number of supported inputs */
+	.num_inputs = TVP5146_NUM_INPUTS,
+	.input_list = tvp5146_input_list,
+};
+
+static struct i2c_board_info __initdata tvp5146_i2c_board_info = {
+	I2C_BOARD_INFO(TVP5146_MODULE_NAME, TVP5146_I2C_ADDR),
+	.platform_data = &tvp5146_pdata,
+};
+
+#endif				/* #ifdef CONFIG_VIDEO_TVP5146 */
+
+/*
+ * GPMC timing to access mux registers - values in ns.
+ * Timings based on non-muxed (limited address) GPMC mode of operation
+ */
+static struct gpmc_timings board_gpmc_timings = {
+	.sync_clk = 20,		/* Don't care for async operation */
+
+	.cs_on = 30,		/* Assertion time */
+	.cs_rd_off = 96,	/* Read deassertion time */
+	.cs_wr_off = 150,	/* Write deassertion time */
+
+	.adv_on = 30,		/* Assertion time */
+	.adv_rd_off = 12,	/* Read deassertion time */
+	.adv_wr_off = 150,	/* Write deassertion time */
+
+	.we_on = 60,		/* WE assertion time */
+	.we_off = 150,		/* WE deassertion time */
+
+	.oe_on = 30,		/* OE assertion time */
+	.oe_off = 150,		/* OE deassertion time */
+
+	.page_burst_access = 6,
+	.access = 90,		/* Start-cycle to first data valid delay */
+
+	.rd_cycle = 102,	/* Total read cycle time */
+	.wr_cycle = 186,	/* Total write cycle time */
+};
+
+/**
+ * @brief omap3evmdc_gpmc_init - acquires and configures BOARD_GPMC_CS GPMC
+ *                               chip select
+ *
+ * @return result of operation - 0 is success
+ */
+static int omap3evmdc_gpmc_init(void)
+{
+	int err;
+	int cs = BOARD_GPMC_CS;
+	u32 *gpmc_phy_base, *gpmc_vir_base;
+	unsigned long flags;
+
+	err = gpmc_cs_set_timings(cs, &board_gpmc_timings);
+	if (err < 0) {
+		dprintk("Couldn't set GPMC timing for CS%d \n", cs);
+		return err;
+	}
+
+	err =
+	    gpmc_cs_request(cs, SZ_16M, (unsigned long *) &gpmc_phy_base);
+	if (err < 0) {
+		dprintk("gpmc_cs_request failed: err = %d\n\n", err);
+		return err;
+	}
+
+	/* remap the GPMC memory - disable cache since we deal with registers */
+	gpmc_vir_base =
+	    (u32 *) ioremap_nocache((unsigned long) gpmc_phy_base, SZ_16M);
+
+	printk(KERN_INFO MODULE_NAME
+	       ": GPMC cs%d request passed. Physical base: 0x%p "
+	       "Virtual base: 0x%p \n", cs, gpmc_phy_base, gpmc_vir_base);
+
+	if (gpmc_vir_base != NULL) {
+		spin_lock_init(&gpmc_handle.reg_lock);
+
+		gpmc_handle.gpmc_phy_base = gpmc_phy_base;
+		gpmc_handle.gpmc_vir_base = gpmc_vir_base;
+
+		spin_lock_irqsave(&gpmc_handle.reg_lock, flags);
+
+		/* write default values */
+		write_gpmc_reg(BUS_CONTROL1_DEF, REG_BUS_CTRL1);
+		write_gpmc_reg(BUS_CONTROL2_DEF, REG_BUS_CTRL2);
+
+		spin_unlock_irqrestore(&gpmc_handle.reg_lock, flags);
+	}
+
+	return err;
+}
+
+/**
+ * @brief omap3evmdc_init - module init function. Should be called before any
+ *                          client driver init call
+ *
+ * @return result of operation - 0 is success
+ */
+static int __init omap3evmdc_init(void)
+{
+	int err;
+
+	/*
+	 * I2C3 SCL pin mux settings - mux mode 0, pull-up enable, input enable
+	 * Uses the MSB 16-bit of this register, retain the LSB 16-bit.
+	 * This pin is shared with gpio_184 (mux mode 4)
+	 */
+	omap_writel(((omap_readl(REG_CONTROL_PADCONF_I2C2_SDA) &
+		      ~PADCONF_I2C3_SCL_MASK) | PADCONF_I2C3_SCL_DEF),
+		    REG_CONTROL_PADCONF_I2C2_SDA);
+
+	/*
+	 * I2C3 SDA pin mux settings - mux mode 0, pull-up enable, input enable
+	 * Uses the LSB 16-bit of this register, retain the MSB 16-bit.
+	 * This pin is shared with gpio_185 (mux mode 4)
+	 */
+	omap_writel(((omap_readl(REG_CONTROL_PADCONF_I2C3_SDA) &
+		      ~PADCONF_I2C3_SDA_MASK) | PADCONF_I2C3_SDA_DEF),
+		    REG_CONTROL_PADCONF_I2C3_SDA);
+
+	/*
+	 * GPMC CS4 pin mux settings - mux mode 0, pull-up enable
+	 * Uses the MSB 16-bit of this register, retain the LSB 16-bit.
+	 * This pin is shared with sys_ndmareq1 (mux mode 1), mcbsp4_clkx
+	 * (mux mode 2), gpt9_pwm_evt (mux mode 3), gpio_55 (mux mode 4)
+	 */
+	omap_writel(((omap_readl(REG_CONTROL_PADCONF_GPMC_NCS3) &
+		      ~PADCONF_GPMC_NCS4_MASK) | PADCONF_GPMC_NCS4_DEF),
+		    REG_CONTROL_PADCONF_GPMC_NCS3);
+
+	err = omap3evmdc_gpmc_init();
+	if (err) {
+		dprintk("GPMC init failed \n");
+		return err;
+	}
+
+	/*
+	 * Register each of the I2C devices present in the board to the I2C
+	 * framework.
+	 * If more I2C devices are added, then each device information should
+	 * be registered with I2C using i2c_register_board_info().
+	 */
+#if defined(CONFIG_VIDEO_TVP5146) || defined(CONFIG_VIDEO_TVP5146_MODULE)
+	err = i2c_register_board_info(BOARD_I2C_BUSNUM,
+					&tvp5146_i2c_board_info, 1);
+	if (err) {
+		dprintk("TVP5146 I2C Board Registration failed \n");
+		gpmc_cs_free(BOARD_GPMC_CS);
+		return err;
+	}
+#endif
+
+	printk(KERN_INFO MODULE_NAME ": Driver registration complete \n");
+
+	return 0;
+}
+
+/**
+ * @brief omap3evmdc_exit - module exit function.
+ *
+ * @return result of operation - 0 is success
+ */
+static void __exit omap3evmdc_exit(void)
+{
+	gpmc_cs_free(BOARD_GPMC_CS);
+}
+
+arch_initcall(omap3evmdc_init);
+module_exit(omap3evmdc_exit);
+
+MODULE_AUTHOR("Texas Instruments");
+MODULE_DESCRIPTION("OMAP3 EVM Daughter Card Driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-omap2/board-omap3evm-dc.h b/arch/arm/mach-omap2/board-omap3evm-dc.h
new file mode 100644
index 0000000..16e68b6
--- /dev/null
+++ b/arch/arm/mach-omap2/board-omap3evm-dc.h
@@ -0,0 +1,49 @@
+/*
+ * arch/arm/mach-omap2/board-omap3evm-dc.h
+ *
+ * Copyright (C) 2008 Texas Instruments Inc
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef __BOARD_OMAP3EVM_DC_H_
+#define __BOARD_OMAP3EVM_DC_H_
+
+/* mux id to enable/disable signal routing to different peripherals */
+enum omap3evmdc_mux {
+	MUX_TVP5146 = 0,
+	MUX_AIC23_MCBSP2,
+	MUX_SPDIF_MCBSP2,
+	MUX_HDMI_MCBSP2,
+	MUX_BT_MCBSP3,
+	MUX_JAC_MCSPI2,
+	MUX_BT_UART1,
+	MUX_MLC_NAND,		/* not connected */
+	MUX_JAC_MCBSP1,
+	MUX_IMAGE_SENSOR,
+	MUX_JAC_MCBSP3,
+	MUX_SPDIF_MCSPI2,
+	NUM_MUX
+};
+
+/* enum to enable or disable mux */
+enum config_mux {
+	DISABLE_MUX,
+	ENABLE_MUX
+};
+
+int omap3evmdc_set_mux(enum omap3evmdc_mux mux_id, enum config_mux value);
+
+#endif				/* End of __BOARD_OMAP3EVM_DC_H_ */
diff --git a/arch/arm/mach-omap2/io.c b/arch/arm/mach-omap2/io.c
index c37005f..a0f7658 100644
--- a/arch/arm/mach-omap2/io.c
+++ b/arch/arm/mach-omap2/io.c
@@ -121,13 +121,13 @@ static struct map_desc omap34xx_io_desc[] __initdata = {
 		.virtual	= L3_34XX_VIRT,
 		.pfn		= __phys_to_pfn(L3_34XX_PHYS),
 		.length		= L3_34XX_SIZE,
-		.type		= MT_DEVICE
+		.type		= MT_MEMORY_SO
 	},
 	{
 		.virtual	= L4_34XX_VIRT,
 		.pfn		= __phys_to_pfn(L4_34XX_PHYS),
 		.length		= L4_34XX_SIZE,
-		.type		= MT_DEVICE
+		.type		= MT_MEMORY_SO
 	},
 	{
 		.virtual	= L4_WK_34XX_VIRT,
@@ -139,19 +139,19 @@ static struct map_desc omap34xx_io_desc[] __initdata = {
 		.virtual	= OMAP34XX_GPMC_VIRT,
 		.pfn		= __phys_to_pfn(OMAP34XX_GPMC_PHYS),
 		.length		= OMAP34XX_GPMC_SIZE,
-		.type		= MT_DEVICE
+		.type		= MT_MEMORY_SO
 	},
 	{
 		.virtual	= OMAP343X_SMS_VIRT,
 		.pfn		= __phys_to_pfn(OMAP343X_SMS_PHYS),
 		.length		= OMAP343X_SMS_SIZE,
-		.type		= MT_DEVICE
+		.type		= MT_MEMORY_SO
 	},
 	{
 		.virtual	= OMAP343X_SDRC_VIRT,
 		.pfn		= __phys_to_pfn(OMAP343X_SDRC_PHYS),
 		.length		= OMAP343X_SDRC_SIZE,
-		.type		= MT_DEVICE
+		.type		= MT_MEMORY_SO
 	},
 	{
 		.virtual	= L4_PER_34XX_VIRT,
@@ -163,7 +163,7 @@ static struct map_desc omap34xx_io_desc[] __initdata = {
 		.virtual	= L4_EMU_34XX_VIRT,
 		.pfn		= __phys_to_pfn(L4_EMU_34XX_PHYS),
 		.length		= L4_EMU_34XX_SIZE,
-		.type		= MT_DEVICE
+		.type		= MT_MEMORY_SO
 	},
 };
 #endif
diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c
index 2d6d682..aadd060 100644
--- a/arch/arm/mm/mmu.c
+++ b/arch/arm/mm/mmu.c
@@ -203,7 +203,7 @@ static struct mem_type mem_types[] = {
 		.prot_l1	= PMD_TYPE_TABLE,
 		.prot_sect	= PROT_SECT_DEVICE | PMD_SECT_WB,
 		.domain		= DOMAIN_IO,
-	},	
+	},
 	[MT_DEVICE_IXP2000] = {	  /* IXP2400 requires XCB=101 for on-chip I/O */
 		.prot_pte	= PROT_PTE_DEVICE,
 		.prot_l1	= PMD_TYPE_TABLE,
@@ -231,6 +231,11 @@ static struct mem_type mem_types[] = {
 		.prot_l1   = PMD_TYPE_TABLE,
 		.domain    = DOMAIN_USER,
 	},
+	[MT_MEMORY_SO] = {
+		.prot_sect = PMD_TYPE_SECT | PMD_SECT_AP_WRITE |
+				PMD_SECT_UNCACHED,
+		.domain    = DOMAIN_KERNEL,
+	},
 	[MT_MEMORY] = {
 		.prot_sect = PMD_TYPE_SECT | PMD_SECT_AP_WRITE,
 		.domain    = DOMAIN_KERNEL,
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index a261b03..f8e1034 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -290,6 +290,17 @@ config VIDEO_OV9640
 	  OV9640 camera.  It is currently working with the TI OMAP2
 	  camera controller.
 
+config VIDEO_TVP5146
+	tristate "Texas Instruments TVP5146 video decoder"
+	depends on I2C && VIDEO_V4L2
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the TI TVP5146
+	  decoder. It is currently working with the TI OMAP3 camera
+	  controller.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tvp5146.
+
 config VIDEO_SAA7110
 	tristate "Philips SAA7110 video decoder"
 	depends on VIDEO_V4L1 && I2C
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index 4085502..472e775 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -110,6 +110,7 @@ obj-$(CONFIG_VIDEO_OMAP3_CAMERA) += omap34xxcam.o
 
 obj-$(CONFIG_VIDEO_TCM825X) += tcm825x.o
 obj-$(CONFIG_VIDEO_OV9640)	+= ov9640.o
+obj-$(CONFIG_VIDEO_TVP5146) += tvp5146.o
 
 obj-$(CONFIG_USB_DABUSB)        += dabusb.o
 obj-$(CONFIG_USB_OV511)         += ov511.o
diff --git a/drivers/media/video/isp/Kconfig b/drivers/media/video/isp/Kconfig
index eeabc8f..e54b04c 100644
--- a/drivers/media/video/isp/Kconfig
+++ b/drivers/media/video/isp/Kconfig
@@ -1,9 +1,14 @@
 # Kconfig for OMAP3 ISP driver
+config VIDEO_OMAP3_ISP
+	bool "OMAP ISP Library"
+	depends on VIDEO_OMAP3 && !ARCH_OMAP3410
 
 config VIDEO_OMAP34XX_ISP_PREVIEWER
 	tristate "OMAP ISP Previewer"
 	depends on !ARCH_OMAP3410
+	select VIDEO_OMAP3_ISP
 
 config VIDEO_OMAP34XX_ISP_RESIZER
 	tristate "OMAP ISP Resizer"
 	depends on !ARCH_OMAP3410
+	select VIDEO_OMAP3_ISP
diff --git a/drivers/media/video/isp/Makefile b/drivers/media/video/isp/Makefile
index 925bb49..37b7b29 100644
--- a/drivers/media/video/isp/Makefile
+++ b/drivers/media/video/isp/Makefile
@@ -1,12 +1,12 @@
 # Makefile for OMAP3 ISP driver
 
 ifdef CONFIG_ARCH_OMAP3410
-obj-$(CONFIG_VIDEO_OMAP3) += \
+obj-$(CONFIG_VIDEO_OMAP3_ISP) += \
 	isp.o ispccdc.o ispmmu.o
 else
-obj-$(CONFIG_VIDEO_OMAP3) += \
+obj-$(CONFIG_VIDEO_OMAP3_ISP) += \
 	isp.o ispccdc.o ispmmu.o \
-	isppreview.o ispresizer.o isph3a.o isphist.o
+	isppreview.o ispresizer.o isph3a.o isphist.o isp_af.o
 
 obj-$(CONFIG_VIDEO_OMAP34XX_ISP_PREVIEWER) += \
 	omap_previewer.o
diff --git a/drivers/media/video/isp/isp.c b/drivers/media/video/isp/isp.c
index 8d1fe14..6b8eea7 100644
--- a/drivers/media/video/isp/isp.c
+++ b/drivers/media/video/isp/isp.c
@@ -45,9 +45,16 @@
 #include "ispccdc.h"
 #include "isph3a.h"
 #include "isphist.h"
+#include "isp_af.h"
 #include "isppreview.h"
 #include "ispresizer.h"
 
+/* Enum for progressive and interlaced field capture */
+enum capture_mode {
+	MODE_PROGRESSIVE,
+	MODE_INTERLACED
+};
+
 /* List of image formats supported via OMAP ISP */
 const static struct v4l2_fmtdesc isp_formats[] = {
 	{
@@ -115,7 +122,6 @@ static struct vcontrol {
 	}
 };
 
-
 /**
  * struct ispirq - Structure for containing callbacks to be called in ISP ISR.
  * @isp_callbk: Array which stores callback functions, indexed by the type of
@@ -131,9 +137,9 @@ static struct vcontrol {
  * CBK_LSC_ISR).
  */
 static struct ispirq {
-	isp_callback_t isp_callbk[9];
-	isp_vbq_callback_ptr isp_callbk_arg1[9];
-	void *isp_callbk_arg2[9];
+	isp_callback_t isp_callbk[CBK_END];
+	isp_vbq_callback_ptr isp_callbk_arg1[CBK_END];
+	void *isp_callbk_arg2[CBK_END];
 } ispirq_obj;
 
 /**
@@ -180,6 +186,9 @@ struct isp_sgdma ispsg;
  * @resizer_input_height: ISP Resizer module input image height.
  * @resizer_output_width: ISP Resizer module output image width.
  * @resizer_output_height: ISP Resizer module output image height.
+ * @mode: Interlaced or progressive capture.
+ * @current_field: Current field for interlaced capture.
+ * @input_pixelformat: Pixel format of decoder/sensor.
  */
 struct ispmodule {
 	unsigned int isp_pipeline;
@@ -198,6 +207,66 @@ struct ispmodule {
 	unsigned int resizer_input_height;
 	unsigned int resizer_output_width;
 	unsigned int resizer_output_height;
+	enum capture_mode mode;
+	int current_field;
+	__u32 input_pixelformat;
+};
+
+/**
+ * struct isp_std_config_params - Structure for storing standard information.
+ * @name: String to represent the standard.
+ * @num_pixels: Total number of pixels per line including hblank.
+ * @num_lines: Total number of lines per frame including vblank.
+ * @active_pixels: Number of active pixels per line.
+ * @active_lines: Number of active lines per frame.
+ * @fps: Frames per second.
+ * @pixelformat: Input pixel format.
+ * @field: Field format.
+ * @bytesperline: Total line size in bytes including any alignment adjustments.
+ * @sizeimage: Buffer size in bytes.
+ * @colorspace: V4L2 Colorspace.
+ */
+struct isp_std_config_params {
+	char name[30];
+	unsigned int num_pixels;
+	unsigned int num_lines;
+	unsigned int active_pixels;
+	unsigned int active_lines;
+	unsigned int fps;
+	__u32 pixelformat;
+	enum v4l2_field field;
+	__u32 bytesperline;
+	__u32 sizeimage;
+	enum v4l2_colorspace colorspace;
+};
+
+static struct isp_std_config_params std_params[] = {
+	{
+	 .name = "NTSC",
+	 .num_pixels = 858,
+	 .num_lines = 525,
+	 .active_pixels = 720,
+	 .active_lines = 480,
+	 .fps = 30,
+	 .pixelformat = V4L2_PIX_FMT_UYVY,
+	 .field = V4L2_FIELD_INTERLACED,
+	 .bytesperline = (720 * 2),
+	 .sizeimage = (720 * 2 * 480),
+	 .colorspace = V4L2_COLORSPACE_SMPTE170M,
+	},
+	{
+	 .name = "PAL",
+	 .num_pixels = 864,
+	 .num_lines = 625,
+	 .active_pixels = 720,
+	 .active_lines = 576,
+	 .fps = 25,
+	 .pixelformat = V4L2_PIX_FMT_UYVY,
+	 .field = V4L2_FIELD_INTERLACED,
+	 .bytesperline = (720 * 2),
+	 .sizeimage = (720 * 2 * 576),
+	 .colorspace = V4L2_COLORSPACE_SMPTE170M,
+	}
 };
 
 static struct ispmodule ispmodule_obj = {
@@ -213,6 +282,9 @@ static struct ispmodule ispmodule_obj = {
 		.colorspace = V4L2_COLORSPACE_JPEG,
 		.priv = 0,
 	},
+	.mode = MODE_PROGRESSIVE,
+	.current_field = 0,
+	.input_pixelformat = V4L2_PIX_FMT_UYVY,
 };
 
 /* Structure for saving/restoring ISP module registers */
@@ -400,6 +472,12 @@ int isp_set_callback(enum isp_callback_type type, isp_callback_t callback,
 					IRQ0ENABLE_H3A_AWB_DONE_IRQ,
 					ISP_IRQ0ENABLE);
 		break;
+	case CBK_H3A_AF_DONE:
+		omap_writel(IRQ0ENABLE_H3A_AF_DONE_IRQ, ISP_IRQ0STATUS);
+		omap_writel(omap_readl(ISP_IRQ0ENABLE)|
+				IRQ0ENABLE_H3A_AF_DONE_IRQ,
+				ISP_IRQ0ENABLE);
+		break;
 	case CBK_HIST_DONE:
 		omap_writel(IRQ0ENABLE_HIST_DONE_IRQ, ISP_IRQ0STATUS);
 		omap_writel(omap_readl(ISP_IRQ0ENABLE) |
@@ -477,6 +555,10 @@ int isp_unset_callback(enum isp_callback_type type)
 						~IRQ0ENABLE_H3A_AWB_DONE_IRQ,
 						ISP_IRQ0ENABLE);
 		break;
+	case CBK_H3A_AF_DONE:
+		omap_writel((omap_readl(ISP_IRQ0ENABLE)) &
+				(~IRQ0ENABLE_H3A_AF_DONE_IRQ), ISP_IRQ0ENABLE);
+		break;
 	case CBK_HIST_DONE:
 		omap_writel((omap_readl(ISP_IRQ0ENABLE)) &
 						~IRQ0ENABLE_HIST_DONE_IRQ,
@@ -510,6 +592,11 @@ EXPORT_SYMBOL(isp_unset_callback);
  **/
 int isp_request_interface(enum isp_interface_type if_t)
 {
+	enum isp_interface_type temp_if_t = if_t;
+
+	if (if_t == ISP_PARLL_YUV_BT)
+		if_t = ISP_PARLL;
+
 	if (isp_obj.if_status & if_t) {
 		DPRINTK_ISPCTRL("ISP_ERR : Requested Interface already \
 			allocated\n");
@@ -529,7 +616,7 @@ int isp_request_interface(enum isp_interface_type if_t)
 				((isp_obj.if_status == ISP_CSIB) &&
 				(if_t == ISP_CSIA)) ||
 				(isp_obj.if_status == 0)) {
-		isp_obj.if_status |= if_t;
+		isp_obj.if_status |= (if_t | temp_if_t);
 		return 0;
 	} else {
 		DPRINTK_ISPCTRL("ISP_ERR : Invalid Combination Serial- \
@@ -550,6 +637,9 @@ EXPORT_SYMBOL(isp_request_interface);
  **/
 int isp_free_interface(enum isp_interface_type if_t)
 {
+	if ((if_t == ISP_PARLL) || (if_t == ISP_PARLL_YUV_BT))
+		if_t |= (ISP_PARLL | ISP_PARLL_YUV_BT);
+
 	isp_obj.if_status &= ~if_t;
 	return 0;
 }
@@ -851,6 +941,7 @@ int isp_configure_interface(struct isp_interface_config *config)
 	ispctrl_val &= (ISPCTRL_PAR_SER_CLK_SEL_MASK);
 	switch (config->ccdc_par_ser) {
 	case ISP_PARLL:
+	case ISP_PARLL_YUV_BT:
 		ispctrl_val |= ISPCTRL_PAR_SER_CLK_SEL_PARALLEL;
 		ispctrl_val |= (config->u.par.par_clk_pol
 						<< ISPCTRL_PAR_CLK_POL_SHIFT);
@@ -935,6 +1026,12 @@ static irqreturn_t omap34xx_isp_isr(int irq, void *ispirq_disp)
 
 	spin_lock_irqsave(&isp_obj.lock, irqflags);
 
+	if (irqdis->isp_callbk[CBK_CATCHALL])
+		irqdis->isp_callbk[CBK_CATCHALL](
+			irqstatus,
+			irqdis->isp_callbk_arg1[CBK_CATCHALL],
+			irqdis->isp_callbk_arg2[CBK_CATCHALL]);
+
 	if ((irqstatus & MMU_ERR) == MMU_ERR) {
 		if (irqdis->isp_callbk[CBK_MMU_ERR])
 			irqdis->isp_callbk[CBK_MMU_ERR](irqstatus,
@@ -1000,6 +1097,14 @@ static irqreturn_t omap34xx_isp_isr(int irq, void *ispirq_disp)
 		is_irqhandled = 1;
 	}
 
+	if ((irqstatus & H3A_AF_DONE) == H3A_AF_DONE) {
+		if (irqdis->isp_callbk[CBK_H3A_AF_DONE])
+			irqdis->isp_callbk[CBK_H3A_AF_DONE](H3A_AF_DONE,
+				irqdis->isp_callbk_arg1[CBK_H3A_AF_DONE],
+				irqdis->isp_callbk_arg2[CBK_H3A_AF_DONE]);
+		is_irqhandled = 1;
+	}
+
 	if (irqstatus & LSC_PRE_ERR) {
 		printk(KERN_ERR "isp_sr: LSC_PRE_ERR \n");
 		omap_writel(irqstatus, ISP_IRQ0STATUS);
@@ -1050,6 +1155,7 @@ void isp_set_pipeline(int soc_type)
 
 	return;
 }
+EXPORT_SYMBOL(isp_set_pipeline);
 
 /**
  * omapisp_unset_callback - Unsets all the callbacks associated with ISP module
@@ -1073,6 +1179,7 @@ void omapisp_unset_callback()
 	}
 	omap_writel(omap_readl(ISP_IRQ0STATUS) | ISP_INT_CLR, ISP_IRQ0STATUS);
 }
+EXPORT_SYMBOL(omapisp_unset_callback);
 
 /**
  * isp_start - Starts ISP submodule
@@ -1088,6 +1195,7 @@ void isp_start(void)
 
 	return;
 }
+EXPORT_SYMBOL(isp_start);
 
 /**
  * isp_stop - Stops isp submodules
@@ -1142,6 +1250,7 @@ void isp_stop()
 	isp_restore_ctx();
 	}
 }
+EXPORT_SYMBOL(isp_stop);
 
 /**
  * isp_set_buf - Sets output address for submodules.
@@ -1169,6 +1278,14 @@ void isp_calc_pipeline(struct v4l2_pix_format *pix_input,
 					struct v4l2_pix_format *pix_output)
 {
 	ispmodule_obj.isp_pipeline = OMAP_ISP_CCDC;
+
+	if (pix_input->field == V4L2_FIELD_NONE)
+		ispmodule_obj.mode = MODE_PROGRESSIVE;	/* Progressive */
+	else
+		ispmodule_obj.mode = MODE_INTERLACED;	/* Interlaced */
+
+	ispmodule_obj.input_pixelformat = pix_input->pixelformat;
+
 	if ((pix_input->pixelformat == V4L2_PIX_FMT_SGRBG10) &&
 		(pix_output->pixelformat != V4L2_PIX_FMT_SGRBG10)) {
 		ispmodule_obj.isp_pipeline |= (OMAP_ISP_PREVIEW |
@@ -1179,9 +1296,14 @@ void isp_calc_pipeline(struct v4l2_pix_format *pix_input,
 	} else {
 		if (pix_input->pixelformat == V4L2_PIX_FMT_SGRBG10)
 			ispccdc_config_datapath(CCDC_RAW, CCDC_OTHERS_MEM);
-		else
-			ispccdc_config_datapath(CCDC_YUV_SYNC,
+		else {
+			if (isp_obj.if_status & ISP_PARLL_YUV_BT)
+				ispccdc_config_datapath(CCDC_YUV_BT,
+							CCDC_OTHERS_MEM);
+			else
+				ispccdc_config_datapath(CCDC_YUV_SYNC,
 							CCDC_OTHERS_MEM);
+		}
 	}
 	return;
 }
@@ -1214,6 +1336,32 @@ void isp_config_pipeline(struct v4l2_pix_format *pix_input,
 			ispmodule_obj.resizer_output_width,
 			ispmodule_obj.resizer_output_height);
 
+	if (pix_input->pixelformat == V4L2_PIX_FMT_UYVY)
+		ispccdc_config_y8pos(Y8POS_ODD);
+	else if (pix_input->pixelformat == V4L2_PIX_FMT_YUYV)
+		ispccdc_config_y8pos(Y8POS_EVEN);
+
+	if (((pix_input->pixelformat == V4L2_PIX_FMT_UYVY) &&
+			(pix_output->pixelformat == V4L2_PIX_FMT_UYVY)) ||
+		((pix_input->pixelformat == V4L2_PIX_FMT_YUYV) &&
+			(pix_output->pixelformat == V4L2_PIX_FMT_YUYV)))
+		/* input and output formats are in same order */
+		ispccdc_config_byteswap(0);
+	else if (((pix_input->pixelformat == V4L2_PIX_FMT_YUYV) &&
+			(pix_output->pixelformat == V4L2_PIX_FMT_UYVY)) ||
+		((pix_input->pixelformat == V4L2_PIX_FMT_UYVY) &&
+			(pix_output->pixelformat == V4L2_PIX_FMT_YUYV)))
+		/* input and output formats are in reverse order */
+		ispccdc_config_byteswap(1);
+
+	/*
+	 * Configure Pitch - This enables application to use a different pitch
+	 * other than active pixels per line.
+	 */
+	if (isp_obj.if_status & ISP_PARLL_YUV_BT)
+		ispccdc_config_outlineoffset(ispmodule_obj.pix.bytesperline,
+						0, 0);
+
 	if (pix_output->pixelformat == V4L2_PIX_FMT_UYVY) {
 		isppreview_config_ycpos(YCPOS_YCrYCb);
 		if (is_ispresizer_enabled())
@@ -1239,9 +1387,26 @@ void isp_vbq_done(unsigned long status, isp_vbq_callback_ptr arg1, void *arg2)
 	int notify = 0;
 	int rval = 0;
 	unsigned long flags;
+	unsigned long fld_stat = (omap_readl(ISPCCDC_SYN_MODE) >> 15) & 0x1;
 
 	switch (status) {
 	case CCDC_VD0:
+		if (ispmodule_obj.mode == MODE_INTERLACED) {
+			spin_lock(&isp_obj.isp_temp_buf_lock);
+			if (ispmodule_obj.current_field != fld_stat) {
+				if (fld_stat == 0)
+					ispmodule_obj.current_field = fld_stat;
+
+				spin_unlock(&isp_obj.isp_temp_buf_lock);
+				return;
+			}
+			spin_unlock(&isp_obj.isp_temp_buf_lock);
+
+			if (fld_stat == 0) {	/* Skip even fields */
+				return;
+			}
+		}
+
 		ispccdc_config_shadow_registers();
 		if ((ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER) ||
 			(ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW))
@@ -1259,6 +1424,23 @@ void isp_vbq_done(unsigned long status, isp_vbq_callback_ptr arg1, void *arg2)
 		}
 		break;
 	case CCDC_VD1:
+		if (ispmodule_obj.mode == MODE_INTERLACED) {
+			spin_lock(&isp_obj.isp_temp_buf_lock);
+			if (ispmodule_obj.current_field != fld_stat) {
+				if (fld_stat == 0)
+					ispmodule_obj.current_field = fld_stat;
+
+				spin_unlock(&isp_obj.isp_temp_buf_lock);
+				return;
+			}
+
+			if (fld_stat == 0) {	/* Skip even fields */
+				return;
+			}
+
+			spin_unlock(&isp_obj.isp_temp_buf_lock);
+		}
+
 		if ((ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER) ||
 			(ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW))
 			return;
@@ -1303,13 +1485,26 @@ void isp_vbq_done(unsigned long status, isp_vbq_callback_ptr arg1, void *arg2)
 		}
 		break;
 	case HS_VS:
-		spin_lock(&isp_obj.isp_temp_buf_lock);
-		if (ispmodule_obj.isp_temp_state == ISP_BUF_TRAN) {
-			isp_CCDC_VD01_enable();
-			ispmodule_obj.isp_temp_state = ISP_BUF_INIT;
+		if (ispmodule_obj.mode == MODE_INTERLACED) {
+			ispmodule_obj.current_field ^= 1;
+			spin_lock(&isp_obj.isp_temp_buf_lock);
+			if ((ispmodule_obj.isp_temp_state == ISP_BUF_TRAN) &&
+			    (fld_stat == 1)) {
+				isp_CCDC_VD01_enable();
+				ispmodule_obj.current_field = fld_stat;
+				ispmodule_obj.isp_temp_state = ISP_BUF_INIT;
+			}
+			spin_unlock(&isp_obj.isp_temp_buf_lock);
+			return;
+		} else {
+			spin_lock(&isp_obj.isp_temp_buf_lock);
+			if (ispmodule_obj.isp_temp_state == ISP_BUF_TRAN) {
+				isp_CCDC_VD01_enable();
+				ispmodule_obj.isp_temp_state = ISP_BUF_INIT;
+			}
+			spin_unlock(&isp_obj.isp_temp_buf_lock);
+			return;
 		}
-		spin_unlock(&isp_obj.isp_temp_buf_lock);
-		return;
 	default:
 		break;
 	}
@@ -1343,6 +1538,7 @@ void isp_sgdma_init()
 		ispsg.sg_state[sg].arg = NULL;
 	}
 }
+EXPORT_SYMBOL(isp_sgdma_init);
 
 /**
  * isp_sgdma_process - Sets operations and config for specified SG DMA
@@ -1447,6 +1643,7 @@ int isp_sgdma_queue(struct videobuf_dmabuf *vdma, struct videobuf_buffer *vb,
 
 	return 0;
 }
+EXPORT_SYMBOL(isp_sgdma_queue);
 
 /**
  * isp_vbq_prepare - Videobuffer queue prepare.
@@ -1476,6 +1673,7 @@ int isp_vbq_prepare(struct videobuf_queue *vbq, struct videobuf_buffer *vb,
 
 	return err;
 }
+EXPORT_SYMBOL(isp_vbq_prepare);
 
 /**
  * isp_vbq_release - Videobuffer queue release.
@@ -1488,6 +1686,7 @@ void isp_vbq_release(struct videobuf_queue *vbq, struct videobuf_buffer *vb)
 	ispsg.isp_addr_capture[vb->i] = (dma_addr_t) NULL;
 	return;
 }
+EXPORT_SYMBOL(isp_vbq_release);
 
 /**
  * isp_queryctrl - Query V4L2 control from existing controls in ISP.
@@ -1509,6 +1708,7 @@ int isp_queryctrl(struct v4l2_queryctrl *a)
 	*a = video_control[i].qc;
 	return 0;
 }
+EXPORT_SYMBOL(isp_queryctrl);
 
 /**
  * isp_g_ctrl - Gets value of the desired V4L2 control.
@@ -1541,6 +1741,7 @@ int isp_g_ctrl(struct v4l2_control *a)
 
 	return rval;
 }
+EXPORT_SYMBOL(isp_g_ctrl);
 
 /**
  * isp_s_ctrl - Sets value of the desired V4L2 control.
@@ -1582,6 +1783,7 @@ int isp_s_ctrl(struct v4l2_control *a)
 
 	return rval;
 }
+EXPORT_SYMBOL(isp_s_ctrl);
 
 /**
  * isp_handle_private - Handle all private ioctls for isp module.
@@ -1604,51 +1806,49 @@ int isp_handle_private(int cmd, void *arg)
 	case VIDIOC_PRIVATE_ISP_PRV_CFG:
 		rval = omap34xx_isp_preview_config(arg);
 		break;
-	case VIDIOC_PRIVATE_ISP_AEWB_CFG:
-		if (!arg)
-			rval = -EFAULT;
-		else {
-			struct isph3a_aewb_config *params;
-			params = (struct isph3a_aewb_config *) arg;
-			rval = isph3a_aewb_configure(params);
+	case VIDIOC_PRIVATE_ISP_AEWB_CFG: {
+		struct isph3a_aewb_config *params;
+		params = (struct isph3a_aewb_config *) arg;
+		rval = isph3a_aewb_configure(params);
 		}
 		break;
-	case VIDIOC_PRIVATE_ISP_AEWB_REQ:
-		if (!arg)
-			rval = -EFAULT;
-		else {
-			struct isph3a_aewb_data *data;
-			data = (struct isph3a_aewb_data *) arg;
-			rval = isph3a_aewb_request_statistics(data);
+	case VIDIOC_PRIVATE_ISP_AEWB_REQ: {
+		struct isph3a_aewb_data *data;
+		data = (struct isph3a_aewb_data *) arg;
+		rval = isph3a_aewb_request_statistics(data);
 		}
 		break;
-	case VIDIOC_PRIVATE_ISP_HIST_CFG:
-	if (!arg)
-			rval = -EFAULT;
-		else {
-			struct isp_hist_config *params;
-
-			params = (struct isp_hist_config *) arg;
-			rval = isp_hist_configure(params);
+	case VIDIOC_PRIVATE_ISP_HIST_CFG: {
+		struct isp_hist_config *params;
+		params = (struct isp_hist_config *) arg;
+		rval = isp_hist_configure(params);
 		}
 		break;
-	case VIDIOC_PRIVATE_ISP_HIST_REQ:
-	if (!arg)
-			rval = -EFAULT;
-		else {
-			struct isp_hist_data *data;
-
-			data = (struct isp_hist_data *) arg;
-			rval = isp_hist_request_statistics(data);
+	case VIDIOC_PRIVATE_ISP_HIST_REQ: {
+		struct isp_hist_data *data;
+		data = (struct isp_hist_data *) arg;
+		rval = isp_hist_request_statistics(data);
 		}
 		break;
+	case VIDIOC_PRIVATE_ISP_AF_CFG: {
+		struct af_configuration *params;
+		params = (struct af_configuration *) arg;
+		rval = isp_af_configure(params);
+		}
+	break;
+	case VIDIOC_PRIVATE_ISP_AF_REQ: {
+		struct isp_af_data *data;
+		data = (struct isp_af_data *) arg;
+		rval = isp_af_request_statistics(data);
+		}
+	break;
 	default:
 		rval = -EINVAL;
 		break;
 	}
-
 	return rval;
 }
+EXPORT_SYMBOL(isp_handle_private);
 
 /**
  * isp_enum_fmt_cap - Gets more information of chosen format index and type
@@ -1662,8 +1862,12 @@ int isp_enum_fmt_cap(struct v4l2_fmtdesc *f)
 	int index = f->index;
 	enum v4l2_buf_type type = f->type;
 	int rval = -EINVAL;
+	int num_formats = NUM_ISP_CAPTURE_FORMATS;
 
-	if (index >= NUM_ISP_CAPTURE_FORMATS)
+	if (ispmodule_obj.input_pixelformat != V4L2_PIX_FMT_SGRBG10)
+		num_formats--;
+
+	if (index >= num_formats)
 		goto err;
 
 	memset(f, 0, sizeof(*f));
@@ -1691,11 +1895,12 @@ EXPORT_SYMBOL(isp_enum_fmt_cap);
  * isp_g_fmt_cap - Gets current output image format.
  * @f: Pointer to V4L2 format structure to be filled with current output format
  **/
-void isp_g_fmt_cap(struct v4l2_format *f)
+void isp_g_fmt_cap(struct v4l2_pix_format *pix)
 {
-	f->fmt.pix = ispmodule_obj.pix;
+	*pix = ispmodule_obj.pix;
 	return;
 }
+EXPORT_SYMBOL(isp_g_fmt_cap);
 
 /**
  * isp_s_fmt_cap - Sets I/O formats and crop and configures pipeline in ISP
@@ -1769,6 +1974,7 @@ void isp_config_crop(struct v4l2_pix_format *croppix)
 
 	return;
 }
+EXPORT_SYMBOL(isp_config_crop);
 
 /**
  * isp_g_crop - Gets crop rectangle size and position.
@@ -1783,6 +1989,7 @@ int isp_g_crop(struct v4l2_crop *a)
 	crop->c = ispcroprect;
 	return 0;
 }
+EXPORT_SYMBOL(isp_g_crop);
 
 /**
  * isp_s_crop - Sets crop rectangle size and position and queues crop operation
@@ -1817,6 +2024,7 @@ int isp_s_crop(struct v4l2_crop *a, struct v4l2_pix_format *pix)
 out:
 	return rval;
 }
+EXPORT_SYMBOL(isp_s_crop);
 
 /**
  * isp_try_fmt_cap - Tries desired input/output image formats
@@ -1923,14 +2131,25 @@ int isp_try_fmt(struct v4l2_pix_format *pix_input,
 	if (ifmt == NUM_ISP_CAPTURE_FORMATS)
 		ifmt = 1;
 	pix_output->pixelformat = isp_formats[ifmt].pixelformat;
-	pix_output->field = V4L2_FIELD_NONE;
-	pix_output->bytesperline = pix_output->width * ISP_BYTES_PER_PIXEL;
-	pix_output->sizeimage = pix_output->bytesperline * pix_output->height;
+
+	if (isp_obj.if_status & ISP_PARLL_YUV_BT)
+		pix_output->field = pix_input->field;
+	else {
+		pix_output->field = V4L2_FIELD_NONE;
+		pix_output->bytesperline =
+				pix_output->width * ISP_BYTES_PER_PIXEL;
+	}
+
+	pix_output->sizeimage =
+		PAGE_ALIGN(pix_output->bytesperline * pix_output->height);
 	pix_output->priv = 0;
 	switch (pix_output->pixelformat) {
 	case V4L2_PIX_FMT_YUYV:
 	case V4L2_PIX_FMT_UYVY:
-		pix_output->colorspace = V4L2_COLORSPACE_JPEG;
+		if (isp_obj.if_status & ISP_PARLL_YUV_BT)
+			pix_output->colorspace = pix_input->colorspace;
+		else
+			pix_output->colorspace = V4L2_COLORSPACE_JPEG;
 		break;
 	default:
 		pix_output->colorspace = V4L2_COLORSPACE_SRGB;
@@ -1948,6 +2167,81 @@ int isp_try_fmt(struct v4l2_pix_format *pix_input,
 
 	return 0;
 }
+
+/**
+ * isp_configure_std - Configures ISP depending on standard.
+ * @std: Standard id
+ *
+ * Returns 0 if ISP is configured, error value if standard not supported.
+ */
+int isp_configure_std(v4l2_std_id std)
+{
+	struct isp_std_config_params *params;
+	int rval = 0;
+	struct v4l2_pix_format pix_input, pix_output;
+
+	if (std & V4L2_STD_NTSC)
+		params = &std_params[0];
+	else if (std & V4L2_STD_PAL)
+		params = &std_params[1];
+	else
+		return -EINVAL;
+
+	ispmodule_obj.pix.pixelformat = params->pixelformat;
+	ispmodule_obj.pix.width = params->active_pixels;
+	ispmodule_obj.pix.height = params->active_lines;
+	ispmodule_obj.pix.field = params->field;
+	ispmodule_obj.pix.bytesperline = params->bytesperline;
+	ispmodule_obj.pix.sizeimage = params->sizeimage;
+	ispmodule_obj.pix.colorspace = params->colorspace;
+
+	if ((std & V4L2_STD_NTSC) || (std & V4L2_STD_PAL)) {
+		pix_input = ispmodule_obj.pix;
+		pix_output = ispmodule_obj.pix;
+	} else
+		return -EINVAL;
+
+	rval = isp_s_fmt_cap(&pix_input, &pix_output);
+
+	return rval;
+}
+EXPORT_SYMBOL(isp_configure_std);
+
+/**
+ * isp_check_format - Checks for proper pixel parameters.
+ * @pixfmt: V4L2 pixel format to validate.
+ *
+ * Returns 0 if pixel formats are proper else returns error.
+ */
+int isp_check_format(struct v4l2_pix_format *pixfmt)
+{
+	u32 hpitch, vpitch;
+
+	if (pixfmt->bytesperline <= 0) {
+		DPRINTK_ISPCTRL("Invalid pitch\n");
+		return -EINVAL;
+	}
+
+	hpitch = pixfmt->bytesperline;
+	vpitch = pixfmt->sizeimage / hpitch;
+
+	/* Check for valid value of pitch */
+	if ((hpitch < ispmodule_obj.pix.width * 2) ||
+	    (vpitch < ispmodule_obj.pix.height)) {
+		DPRINTK_ISPCTRL("Invalid pitch\n");
+		return -EINVAL;
+	}
+	/* Check for 32 byte alignment */
+	if (hpitch != (hpitch & ~0x1F)) {
+		DPRINTK_ISPCTRL("Invalid pitch alignment\n");
+		return -EINVAL;
+	}
+	pixfmt->width = ispmodule_obj.pix.width;
+	pixfmt->height = ispmodule_obj.pix.height;
+	return 0;
+}
+EXPORT_SYMBOL(isp_check_format);
+
 /**
  * isp_save_ctx - Saves ISP, CCDC, HIST, H3A, PREV, RESZ & MMU context.
  *
@@ -2025,7 +2319,6 @@ int isp_get(void)
 	isp_obj.ref_count++;
 	mutex_unlock(&(isp_obj.isp_mutex));
 
-
 	DPRINTK_ISPCTRL("isp_get: new %d\n", isp_obj.ref_count);
 	return isp_obj.ref_count;
 
@@ -2106,16 +2399,24 @@ static int __init isp_init(void)
 
 	mutex_init(&(isp_obj.isp_mutex));
 	spin_lock_init(&isp_obj.isp_temp_buf_lock);
+	spin_lock_init(&isp_obj.lock);
 
 	if (request_irq(INT_34XX_CAM_IRQ, omap34xx_isp_isr, IRQF_SHARED,
 				"Omap 34xx Camera ISP", &ispirq_obj)) {
 		DPRINTK_ISPCTRL("Could not install ISR\n");
 		return -EINVAL;
-	} else {
-		spin_lock_init(&isp_obj.lock);
-		DPRINTK_ISPCTRL("-isp_init for Omap 3430 Camera ISP\n");
-		return 0;
 	}
+
+	isp_ccdc_init();
+	isp_hist_init();
+	isph3a_aewb_init();
+	ispmmu_init();
+	isp_preview_init();
+	isp_resizer_init();
+	isp_af_init();
+
+	DPRINTK_ISPCTRL("-isp_init for Omap 3430 Camera ISP\n");
+	return 0;
 }
 
 /**
@@ -2123,6 +2424,13 @@ static int __init isp_init(void)
  **/
 static void __exit isp_cleanup(void)
 {
+	isp_af_exit();
+	isp_resizer_cleanup();
+	isp_preview_cleanup();
+	ispmmu_cleanup();
+	isph3a_aewb_cleanup();
+	isp_hist_cleanup();
+	isp_ccdc_cleanup();
 	free_irq(INT_34XX_CAM_IRQ, &ispirq_obj);
 }
 
diff --git a/drivers/media/video/isp/isp.h b/drivers/media/video/isp/isp.h
index 3f2d43d..4f7c96e 100644
--- a/drivers/media/video/isp/isp.h
+++ b/drivers/media/video/isp/isp.h
@@ -50,9 +50,9 @@
 #define VIDIOC_PRIVATE_ISP_HIST_REQ \
 	_IOWR('V', BASE_VIDIOC_PRIVATE + 7, struct isp_hist_data)
 #define VIDIOC_PRIVATE_ISP_AF_CFG \
-	_IO('V', BASE_VIDIOC_PRIVATE + 8)
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 8, struct af_configuration)
 #define VIDIOC_PRIVATE_ISP_AF_REQ \
-	_IO('V', BASE_VIDIOC_PRIVATE + 9)
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 9, struct isp_af_data)
 
 #define ISP_TOK_TERM		0xFFFFFFFF	/*
 						 * terminating token for ISP
@@ -94,7 +94,8 @@ typedef void (*isp_callback_t) (unsigned long status,
 enum isp_interface_type {
 	ISP_PARLL = 1,
 	ISP_CSIA = 2,
-	ISP_CSIB = 4
+	ISP_CSIB = 4,
+	ISP_PARLL_YUV_BT = 8
 };
 
 enum isp_irqevents {
@@ -103,6 +104,7 @@ enum isp_irqevents {
 	CCDC_VD2 = 0x400,
 	CCDC_ERR = 0x800,
 	H3A_AWB_DONE = 0x2000,
+	H3A_AF_DONE = 0x1000,
 	HIST_DONE = 0x10000,
 	PREV_DONE = 0x100000,
 	LSC_DONE = 0x20000,
@@ -124,7 +126,10 @@ enum isp_callback_type {
 	CBK_H3A_AWB_DONE,
 	CBK_HIST_DONE,
 	CBK_HS_VS,
-	CBK_LSC_ISR
+	CBK_LSC_ISR,
+	CBK_H3A_AF_DONE,
+	CBK_CATCHALL,
+	CBK_END,
 };
 
 /**
@@ -294,7 +299,7 @@ int isp_enum_fmt_cap(struct v4l2_fmtdesc *f);
 int isp_try_fmt_cap(struct v4l2_pix_format *pix_input,
 					struct v4l2_pix_format *pix_output);
 
-void isp_g_fmt_cap(struct v4l2_format *f);
+void isp_g_fmt_cap(struct v4l2_pix_format *pix);
 
 int isp_s_fmt_cap(struct v4l2_pix_format *pix_input,
 					struct v4l2_pix_format *pix_output);
@@ -311,6 +316,10 @@ int isp_try_size(struct v4l2_pix_format *pix_input,
 int isp_try_fmt(struct v4l2_pix_format *pix_input,
 					struct v4l2_pix_format *pix_output);
 
+int isp_configure_std(v4l2_std_id std);
+
+int isp_check_format(struct v4l2_pix_format *pixfmt);
+
 int isp_handle_private(int cmd, void *arg);
 
 void isp_save_context(struct isp_reg *);
diff --git a/drivers/media/video/isp/isp_af.c b/drivers/media/video/isp/isp_af.c
new file mode 100644
index 0000000..6939bdc
--- /dev/null
+++ b/drivers/media/video/isp/isp_af.c
@@ -0,0 +1,812 @@
+/*
+ * drivers/media/video/isp/isp_af.c
+ *
+ * AF module for TI's OMAP3430 Camera ISP
+ *
+ * Copyright (C) 2008 Texas Instruments.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/* Linux specific include files */
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <asm/cacheflush.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+
+#include <linux/mman.h>
+#include <linux/syscalls.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/dma-mapping.h>
+
+#include <media/v4l2-int-device.h>
+#include "isp.h"
+#include "ispreg.h"
+#include "isph3a.h"
+#include "isp_af.h"
+#include "ispmmu.h"
+
+/**
+ * struct isp_af_buffer - AF frame stats buffer.
+ * @virt_addr: Virtual address to mmap the buffer.
+ * @phy_addr: Physical address of the buffer.
+ * @addr_align: Virtual Address 32 bytes aligned.
+ * @ispmmu_addr: Address of the buffer mapped by the ISPMMU.
+ * @mmap_addr: Mapped memory area of buffer. For userspace access.
+ * @locked: 1 - Buffer locked from write. 0 - Buffer can be overwritten.
+ * @frame_num: Frame number from which the statistics are taken.
+ * @lens_position: Lens position currently set in the DW9710 Coil motor driver.
+ * @next: Pointer to link next buffer.
+ */
+struct isp_af_buffer {
+	unsigned long virt_addr;
+	unsigned long phy_addr;
+	unsigned long addr_align;
+	unsigned long ispmmu_addr;
+	unsigned long mmap_addr;
+
+	u8 locked;
+	u16 frame_num;
+	struct isp_af_xtrastats xtrastats;
+	struct isp_af_buffer *next;
+};
+
+/**
+ * struct isp_af_status - AF status.
+ * @initialized: 1 - Buffers initialized.
+ * @update: 1 - Update registers.
+ * @stats_req: 1 - Future stats requested.
+ * @stats_done: 1 - Stats ready for user.
+ * @frame_req: Number of frame requested for statistics.
+ * @af_buff: Array of statistics buffers to access.
+ * @stats_buf_size: Statistics buffer size.
+ * @min_buf_size: Minimum statisitics buffer size.
+ * @frame_count: Frame Count.
+ * @stats_wait: Wait primitive for locking/unlocking the stats request.
+ * @buffer_lock: Spinlock for statistics buffers access.
+ */
+static struct isp_af_status {
+	u8 initialized;
+	u8 update;
+	u8 stats_req;
+	u8 stats_done;
+	u16 frame_req;
+
+	struct isp_af_buffer af_buff[H3A_MAX_BUFF];
+	unsigned int stats_buf_size;
+	unsigned int min_buf_size;
+
+	u32 frame_count;
+	wait_queue_head_t stats_wait;
+	spinlock_t buffer_lock;
+} afstat;
+
+struct af_device *af_dev_configptr;
+static struct isp_af_buffer *active_buff;
+static int af_major = -1;
+static int camnotify;
+
+
+/**
+ * isp_af_setxtrastats - Receives extra statistics from prior frames.
+ * @xtrastats: Pointer to structure containing extra statistics fields like
+ *             field count and timestamp of frame.
+ *
+ * Called from update_vbq in camera driver
+ **/
+void isp_af_setxtrastats(struct isp_af_xtrastats *xtrastats, u8 updateflag)
+{
+	int i, past_i;
+
+	if (active_buff == NULL)
+		return;
+
+	for (i = 0; i < H3A_MAX_BUFF; i++) {
+		if (afstat.af_buff[i].frame_num == active_buff->frame_num)
+			break;
+	}
+
+	if (i == H3A_MAX_BUFF)
+		return;
+
+	if (i == 0) {
+		if (afstat.af_buff[H3A_MAX_BUFF - 1].locked == 0)
+			past_i = H3A_MAX_BUFF - 1;
+		else
+			past_i = H3A_MAX_BUFF - 2;
+	} else if (i == 1) {
+		if (afstat.af_buff[0].locked == 0)
+			past_i = 0;
+		else
+			past_i = H3A_MAX_BUFF - 1;
+	} else {
+		if (afstat.af_buff[i - 1].locked == 0)
+			past_i = i - 1;
+		else
+			past_i = i - 2;
+	}
+
+	if (updateflag & AF_UPDATEXS_TS)
+		afstat.af_buff[past_i].xtrastats.ts = xtrastats->ts;
+
+	if (updateflag & AF_UPDATEXS_FIELDCOUNT)
+		afstat.af_buff[past_i].xtrastats.field_count =
+							xtrastats->field_count;
+}
+EXPORT_SYMBOL(isp_af_setxtrastats);
+
+/*
+ * Helper function to update buffer cache pages
+ */
+static void isp_af_update_req_buffer(struct isp_af_buffer *buffer)
+{
+	int size = afstat.stats_buf_size;
+
+	size = PAGE_ALIGN(size);
+	/* Update the kernel pages of the requested buffer */
+	dmac_inv_range((void *)buffer->addr_align, (void *)buffer->addr_align +
+									size);
+}
+
+/* Function to check paxel parameters */
+int isp_af_check_paxel(void)
+{
+	/* Check horizontal Count */
+	if ((af_dev_configptr->config->paxel_config.hz_cnt
+	     < AF_PAXEL_HORIZONTAL_COUNT_MIN)
+	    || (af_dev_configptr->config->paxel_config.hz_cnt
+		> AF_PAXEL_HORIZONTAL_COUNT_MAX)) {
+		DPRINTK_ISPH3A("Error : Horizontal Count is incorrect");
+		return -AF_ERR_HZ_COUNT;
+	}
+
+	/*Check Vertical Count */
+	if ((af_dev_configptr->config->paxel_config.vt_cnt
+	     < AF_PAXEL_VERTICAL_COUNT_MIN)
+	    || (af_dev_configptr->config->paxel_config.vt_cnt
+		> AF_PAXEL_VERTICAL_COUNT_MAX)) {
+		DPRINTK_ISPH3A("Error : Vertical Count is incorrect");
+		return -AF_ERR_VT_COUNT;
+	}
+
+	/*Check Height */
+	if ((af_dev_configptr->config->paxel_config.height
+	     < AF_PAXEL_HEIGHT_MIN)
+	    || (af_dev_configptr->config->paxel_config.height
+		> AF_PAXEL_HEIGHT_MAX)) {
+		DPRINTK_ISPH3A("Error : Height is incorrect");
+		return -AF_ERR_HEIGHT;
+	}
+
+	/*Check width */
+	if ((af_dev_configptr->config->paxel_config.width < AF_PAXEL_WIDTH_MIN)
+	    || (af_dev_configptr->config->paxel_config.width
+		> AF_PAXEL_WIDTH_MAX)) {
+		DPRINTK_ISPH3A("Error : Width is incorrect");
+		return -AF_ERR_WIDTH;
+	}
+
+	/*Check Line Increment */
+	if ((af_dev_configptr->config->paxel_config.line_incr
+	     < AF_PAXEL_INCREMENT_MIN)
+	    || (af_dev_configptr->config->paxel_config.line_incr
+		> AF_PAXEL_INCREMENT_MAX)) {
+		DPRINTK_ISPH3A("Error : Line Increment is incorrect");
+		return -AF_ERR_INCR;
+	}
+
+	/*Check Horizontal Start */
+	if ((af_dev_configptr->config->paxel_config.hz_start % 2 != 0)
+	    || (af_dev_configptr->config->paxel_config.hz_start
+		< (af_dev_configptr->config->iir_config.hz_start_pos + 2))
+	    || (af_dev_configptr->config->paxel_config.hz_start
+		> AF_PAXEL_HZSTART_MAX)
+	    || (af_dev_configptr->config->paxel_config.hz_start
+		< AF_PAXEL_HZSTART_MIN)) {
+		DPRINTK_ISPH3A("Error : Horizontal Start is incorrect");
+		return -AF_ERR_HZ_START;
+	}
+
+	/*Check Vertical Start */
+	if ((af_dev_configptr->config->paxel_config.vt_start
+	     < AF_PAXEL_VTSTART_MIN)
+	    || (af_dev_configptr->config->paxel_config.vt_start
+		> AF_PAXEL_VTSTART_MAX)) {
+		DPRINTK_ISPH3A("Error : Vertical Start is incorrect");
+		return -AF_ERR_VT_START;
+	}
+	return 0;		/*Success */
+}
+
+/**
+ * isp_af_check_iir - Function to check IIR Coefficient.
+ **/
+int isp_af_check_iir(void)
+{
+	int index;
+
+	for (index = 0; index < AF_NUMBER_OF_COEF; index++) {
+		if ((af_dev_configptr->config->iir_config.coeff_set0[index])
+		    > AF_COEF_MAX) {
+			DPRINTK_ISPH3A(
+				"Error : Coefficient for set 0 is incorrect");
+			return -AF_ERR_IIR_COEF;
+		}
+
+		if ((af_dev_configptr->config->iir_config.coeff_set1[index])
+		    > AF_COEF_MAX) {
+			DPRINTK_ISPH3A(
+				"Error : Coefficient for set 1 is incorrect");
+			return -AF_ERR_IIR_COEF;
+		}
+	}
+
+	if ((af_dev_configptr->config->iir_config.hz_start_pos < AF_IIRSH_MIN)
+	    || (af_dev_configptr->config->iir_config.hz_start_pos >
+		AF_IIRSH_MAX)) {
+		DPRINTK_ISPH3A("Error : IIRSH is incorrect");
+		return -AF_ERR_IIRSH;
+	}
+
+	return 0;
+}
+/**
+ * isp_af_unlock_buffers - Helper function to unlock all buffers.
+ **/
+static void isp_af_unlock_buffers(void)
+{
+	int i;
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&afstat.buffer_lock, irqflags);
+	for (i = 0; i < H3A_MAX_BUFF; i++)
+		afstat.af_buff[i].locked = 0;
+
+	spin_unlock_irqrestore(&afstat.buffer_lock, irqflags);
+}
+
+/*
+ * Helper function to link allocated buffers
+ */
+static void isp_af_link_buffers(void)
+{
+	int i;
+
+	for (i = 0; i < H3A_MAX_BUFF; i++) {
+		if ((i + 1) < H3A_MAX_BUFF)
+			afstat.af_buff[i].next = &afstat.af_buff[i + 1];
+		else
+			afstat.af_buff[i].next = &afstat.af_buff[0];
+	}
+}
+
+/*
+ * Helper function to munmap kernel buffers from user space.
+ */
+static int isp_af_munmap(struct isp_af_buffer *buffer)
+{
+	/* TO DO: munmap succesfully the kernel buffers, so they can be
+	   remmaped again */
+	buffer->mmap_addr = 0;
+	return 0;
+}
+
+/*
+ * Helper function to mmap buffers to user space.
+ * buffer passed need to already have a valid physical address: buffer->phy_addr
+ * It returns user pointer as unsigned long in buffer->mmap_addr
+ */
+static int isp_af_mmap_buffers(struct isp_af_buffer *buffer)
+{
+	struct vm_area_struct vma;
+	struct mm_struct *mm = current->mm;
+	int size = afstat.stats_buf_size;
+	unsigned long addr = 0;
+	unsigned long pgoff = 0, flags = MAP_SHARED | MAP_ANONYMOUS;
+	unsigned long prot = PROT_READ | PROT_WRITE;
+	void *pos = (void *)buffer->addr_align;
+
+	size = PAGE_ALIGN(size);
+
+	addr = get_unmapped_area(NULL, addr, size, pgoff, flags);
+	vma.vm_mm = mm;
+	vma.vm_start = addr;
+	vma.vm_end = addr + size;
+	vma.vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags);
+	vma.vm_pgoff = pgoff;
+	vma.vm_file = NULL;
+	vma.vm_page_prot = vm_get_page_prot(vma.vm_flags);
+
+	while (size > 0) {
+		if (vm_insert_page(&vma, addr, vmalloc_to_page(pos)))
+			return -EAGAIN;
+		addr += PAGE_SIZE;
+		pos += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	buffer->mmap_addr = vma.vm_start;
+	return 0;
+}
+
+/* Function to perform hardware set up */
+int isp_af_configure(struct af_configuration *afconfig)
+{
+	int result;
+	int buff_size, i;
+	unsigned int busyaf;
+
+	if (NULL == afconfig) {
+		printk(KERN_ERR "Null argument in configuration. \n");
+		return -EINVAL;
+	}
+
+	af_dev_configptr->config = afconfig;
+	/* Get the value of PCR register */
+	busyaf = omap_readl(ISPH3A_PCR);
+
+	if ((busyaf & AF_BUSYAF) == AF_BUSYAF) {
+		DPRINTK_ISPH3A("AF_register_setup_ERROR : Engine Busy");
+		DPRINTK_ISPH3A("\n Configuration cannot be done ");
+		return -AF_ERR_ENGINE_BUSY;
+	}
+
+	/*Check IIR Coefficient and start Values */
+	result = isp_af_check_iir();
+	if (result < 0)
+		return result;
+
+	/*Check Paxel Values */
+	result = isp_af_check_paxel();
+	if (result < 0)
+		return result;
+
+	/*Check HMF Threshold Values */
+	if (af_dev_configptr->config->hmf_config.threshold > AF_THRESHOLD_MAX) {
+		DPRINTK_ISPH3A("Error : HMF Threshold is incorrect");
+		return -AF_ERR_THRESHOLD;
+	}
+
+	/* Compute buffer size */
+	buff_size =
+	    (af_dev_configptr->config->paxel_config.hz_cnt + 1) *
+	    (af_dev_configptr->config->paxel_config.vt_cnt + 1) * AF_PAXEL_SIZE;
+
+	/*Deallocate the previous buffers */
+	if (afstat.stats_buf_size && (buff_size	> afstat.stats_buf_size)) {
+		isp_af_enable(0);
+		for (i = 0; i < H3A_MAX_BUFF; i++) {
+			isp_af_munmap(&afstat.af_buff[i]);
+			ispmmu_unmap(afstat.af_buff[i].ispmmu_addr);
+			dma_free_coherent(NULL,
+				  afstat.min_buf_size + 64,
+				  (void *)afstat.af_buff[i].virt_addr,
+				  (dma_addr_t)afstat.af_buff[i].phy_addr);
+			afstat.af_buff[i].virt_addr = 0;
+		}
+		afstat.stats_buf_size = 0;
+	}
+
+	if (!afstat.af_buff[0].virt_addr) {
+		afstat.stats_buf_size = buff_size;
+		afstat.min_buf_size = PAGE_ALIGN(afstat.stats_buf_size);
+
+		for (i = 0; i < H3A_MAX_BUFF; i++) {
+			afstat.af_buff[i].virt_addr =
+				(unsigned long)dma_alloc_coherent(NULL,
+						afstat.min_buf_size,
+						(dma_addr_t *)
+						 &afstat.af_buff[i].phy_addr,
+						GFP_KERNEL | GFP_DMA);
+			if (afstat.af_buff[i].virt_addr == 0) {
+				printk(KERN_ERR "Can't acquire memory for "
+					"buffer[%d]\n", i);
+				return -ENOMEM;
+			}
+			afstat.af_buff[i].addr_align =
+					afstat.af_buff[i].virt_addr;
+			while ((afstat.af_buff[i].addr_align & 0xFFFFFFC0) !=
+				       afstat.af_buff[i].addr_align)
+				afstat.af_buff[i].addr_align++;
+			afstat.af_buff[i].ispmmu_addr =
+				ispmmu_map(afstat.af_buff[i].phy_addr,
+					   afstat.min_buf_size);
+		}
+		isp_af_unlock_buffers();
+		isp_af_link_buffers();
+
+		/* First active buffer */
+		if (active_buff == NULL)
+			active_buff = &afstat.af_buff[0];
+		isp_af_set_address(active_buff->ispmmu_addr);
+	}
+	/* Always remap when calling Configure */
+	for (i = 0; i < H3A_MAX_BUFF; i++) {
+		if (afstat.af_buff[i].mmap_addr)
+			isp_af_munmap(&afstat.af_buff[i]);
+		isp_af_mmap_buffers(&afstat.af_buff[i]);
+	}
+
+	result = isp_af_register_setup(af_dev_configptr);
+	if (result < 0)
+		return result;
+	af_dev_configptr->size_paxel = buff_size;
+	afstat.initialized = 1;
+	/*Set configuration flag to indicate HW setup done */
+	if (af_dev_configptr->config->af_config)
+		isp_af_enable(1);
+	else
+		isp_af_enable(0);
+
+	/*Success */
+	return 0;
+}
+EXPORT_SYMBOL(isp_af_configure);
+
+int isp_af_register_setup(struct af_device *af_dev)
+{
+	unsigned int pcr = 0, pax1 = 0, pax2 = 0, paxstart = 0;
+	unsigned int coef = 0;
+	unsigned int base_coef_set0 = 0;
+	unsigned int base_coef_set1 = 0;
+	int index;
+
+
+	/* Configure Hardware Registers */
+	/* Set PCR Register */
+	pcr = omap_readl(ISPH3A_PCR);	/* Read PCR Register */
+
+	/*Set Accumulator Mode */
+	if (af_dev->config->mode == ACCUMULATOR_PEAK)
+		pcr |= FVMODE;
+	else
+		pcr &= ~FVMODE;
+
+	/*Set A-law */
+	if (af_dev->config->alaw_enable == H3A_AF_ALAW_ENABLE)
+		pcr |= AF_ALAW_EN;
+	else
+		pcr &= ~AF_ALAW_EN;
+
+	/*Set RGB Position */
+	pcr &= ~RGBPOS;
+	pcr |= (af_dev->config->rgb_pos) << AF_RGBPOS_SHIFT;
+
+	/*HMF Configurations */
+	if (af_dev->config->hmf_config.enable == H3A_AF_HMF_ENABLE) {
+		pcr &= ~AF_MED_EN;
+		/* Enable HMF */
+		pcr |= AF_MED_EN;
+
+		/* Set Median Threshold */
+		pcr &= ~MED_TH;
+		pcr |=
+		    (af_dev->config->hmf_config.threshold) << AF_MED_TH_SHIFT;
+	} else
+		pcr &= ~AF_MED_EN;
+
+	omap_writel(pcr, ISPH3A_PCR);
+
+	pax1 &= ~PAXW;
+	pax1 |= (af_dev->config->paxel_config.width) << AF_PAXW_SHIFT;
+
+	/* Set height in AFPAX1 */
+	pax1 &= ~PAXH;
+	pax1 |= af_dev->config->paxel_config.height;
+
+	omap_writel(pax1, ISPH3A_AFPAX1);
+
+	/* Configure AFPAX2 Register */
+	/* Set Line Increment in AFPAX2 Register */
+	pax2 &= ~AFINCV;
+	pax2 |= (af_dev->config->paxel_config.line_incr) << AF_LINE_INCR_SHIFT;
+	/* Set Vertical Count */
+	pax2 &= ~PAXVC;
+	pax2 |= (af_dev->config->paxel_config.vt_cnt) << AF_VT_COUNT_SHIFT;
+	/* Set Horizontal Count */
+	pax2 &= ~PAXHC;
+	pax2 |= af_dev->config->paxel_config.hz_cnt;
+	omap_writel(pax2, ISPH3A_AFPAX2);
+
+	/* Configure PAXSTART Register */
+	/*Configure Horizontal Start */
+	paxstart &= ~PAXSH;
+	paxstart |=
+	    (af_dev->config->paxel_config.hz_start) << AF_HZ_START_SHIFT;
+	/* Configure Vertical Start */
+	paxstart &= ~PAXSV;
+	paxstart |= af_dev->config->paxel_config.vt_start;
+	omap_writel(paxstart, ISPH3A_AFPAXSTART);
+
+	/*SetIIRSH Register */
+	omap_writel(af_dev->config->iir_config.hz_start_pos, ISPH3A_AFIIRSH);
+
+	/*Set IIR Filter0 Coefficients */
+	base_coef_set0 = ISPH3A_AFCOEF010;
+	for (index = 0; index <= 8; index += 2) {
+		coef &= ~COEF_MASK0;
+		coef |= af_dev->config->iir_config.coeff_set0[index];
+		coef &= ~COEF_MASK1;
+		coef |=
+		    (af_dev->config->iir_config.
+		     coeff_set0[index + 1]) << AF_COEF_SHIFT;
+		omap_writel(coef, base_coef_set0);
+
+		base_coef_set0 = base_coef_set0 + AFCOEF_OFFSET;
+	}
+
+	/* set AFCOEF0010 Register */
+	omap_writel(af_dev->config->iir_config.coeff_set0[10],
+							ISPH3A_AFCOEF010);
+
+	/*Set IIR Filter1 Coefficients */
+
+	base_coef_set1 = ISPH3A_AFCOEF110;
+	for (index = 0; index <= 8; index += 2) {
+		coef &= ~COEF_MASK0;
+		coef |= af_dev->config->iir_config.coeff_set1[index];
+		coef &= ~COEF_MASK1;
+		coef |=
+		    (af_dev->config->iir_config.
+		     coeff_set1[index + 1]) << AF_COEF_SHIFT;
+		omap_writel(coef, base_coef_set1);
+
+		base_coef_set1 = base_coef_set1 + AFCOEF_OFFSET;
+	}
+	omap_writel(af_dev->config->iir_config.coeff_set1[10],
+							ISPH3A_AFCOEF1010);
+
+	return 0;
+}
+
+/* Function to set address */
+void isp_af_set_address(unsigned long address)
+{
+	omap_writel(address, ISPH3A_AFBUFST);
+}
+
+static int isp_af_stats_available(struct isp_af_data *afdata)
+{
+	int i;
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&afstat.buffer_lock, irqflags);
+	for (i = 0; i < H3A_MAX_BUFF; i++) {
+		if ((afdata->frame_number == afstat.af_buff[i].frame_num)
+			&& (afstat.af_buff[i].frame_num !=
+				active_buff->frame_num)) {
+			afstat.af_buff[i].locked = 1;
+			spin_unlock_irqrestore(&afstat.buffer_lock, irqflags);
+			isp_af_update_req_buffer(&afstat.af_buff[i]);
+			afstat.af_buff[i].frame_num = 0;
+			afdata->af_statistics_buf = (void *)
+				afstat.af_buff[i].mmap_addr;
+			afdata->xtrastats.ts = afstat.af_buff[i].xtrastats.ts;
+			afdata->xtrastats.field_count =
+				afstat.af_buff[i].xtrastats.field_count;
+			return 0;
+		}
+	}
+	spin_unlock_irqrestore(&afstat.buffer_lock, irqflags);
+	/* Stats unavailable */
+
+	afdata->af_statistics_buf = NULL;
+	return -1;
+}
+
+void isp_af_notify(int notify)
+{
+	camnotify = notify;
+	if (camnotify && afstat.initialized) {
+		printk(KERN_DEBUG "Warning Camera Off \n");
+		afstat.stats_req = 0;
+		afstat.stats_done = 1;
+		wake_up_interruptible(&afstat.stats_wait);
+	}
+}
+EXPORT_SYMBOL(isp_af_notify);
+/*
+ * This API allows the user to update White Balance gains, as well as
+ * exposure time and analog gain. It is also used to request frame
+ * statistics.
+ */
+int isp_af_request_statistics(struct isp_af_data *afdata)
+{
+	int ret = 0;
+	u16 frame_diff = 0;
+	u16 frame_cnt = afstat.frame_count;
+	wait_queue_t wqt;
+
+	if (!af_dev_configptr->config->af_config) {
+		printk(KERN_ERR "AF engine not enabled\n");
+		return -EINVAL;
+	}
+	afdata->af_statistics_buf = NULL;
+
+	if (afdata->update != 0) {
+		if (afdata->update & REQUEST_STATISTICS) {
+			isp_af_unlock_buffers();
+				/* Stats available? */
+			DPRINTK_ISPH3A("Stats available?\n");
+			ret = isp_af_stats_available(afdata);
+			if (!ret)
+				goto out;
+
+			/* Stats in near future? */
+			DPRINTK_ISPH3A("Stats in near future?\n");
+			if (afdata->frame_number > frame_cnt) {
+				frame_diff = afdata->frame_number - frame_cnt;
+			} else if (afdata->frame_number < frame_cnt) {
+				if ((frame_cnt >
+					(MAX_FRAME_COUNT - MAX_FUTURE_FRAMES))
+					&& (afdata->frame_number
+						< MAX_FRAME_COUNT))
+					frame_diff = afdata->frame_number
+						    + MAX_FRAME_COUNT
+						    - frame_cnt;
+				else {
+					/* Frame unavailable */
+					frame_diff = MAX_FUTURE_FRAMES + 1;
+					afdata->af_statistics_buf = NULL;
+				}
+			}
+
+			if (frame_diff > MAX_FUTURE_FRAMES) {
+				printk(KERN_ERR "Invalid frame requested\n");
+			} else if (!camnotify) {
+				/* Block until frame in near future completes */
+				afstat.frame_req = afdata->frame_number;
+				afstat.stats_req = 1;
+				afstat.stats_done = 0;
+				init_waitqueue_entry(&wqt, current);
+				ret =
+				   wait_event_interruptible(afstat.stats_wait,
+						afstat.stats_done == 1);
+				if (ret < 0)
+					return ret;
+			DPRINTK_ISPH3A("ISP AF request status"
+						" interrupt raised\n");
+
+				/* Stats now available */
+				ret = isp_af_stats_available(afdata);
+				if (ret) {
+					printk(KERN_ERR "After waiting for"
+						" stats, stats not available!!"
+						"\n");
+				}
+			}
+		}
+	}
+
+out:
+	afdata->curr_frame = afstat.frame_count;
+
+	return 0;
+}
+EXPORT_SYMBOL(isp_af_request_statistics);
+
+/* This function will handle the H3A interrupt. */
+static void isp_af_isr(unsigned long status, isp_vbq_callback_ptr arg1,
+								void *arg2)
+{
+	u16 frame_align;
+
+	if ((H3A_AF_DONE & status) != H3A_AF_DONE)
+		return;
+
+	/* Exchange buffers */
+	active_buff = active_buff->next;
+	if (active_buff->locked == 1)
+		active_buff = active_buff->next;
+	isp_af_set_address(active_buff->ispmmu_addr);
+
+	/* Update frame counter */
+	afstat.frame_count++;
+	frame_align = afstat.frame_count;
+	if (afstat.frame_count > MAX_FRAME_COUNT) {
+		afstat.frame_count = 1;
+		frame_align++;
+	}
+	active_buff->frame_num = afstat.frame_count;
+
+	/* Future Stats requested? */
+	if (afstat.stats_req) {
+		/* Is the frame we want already done? */
+		if (frame_align >= (afstat.frame_req + 1)) {
+			afstat.stats_req = 0;
+			afstat.stats_done = 1;
+			wake_up_interruptible(&afstat.stats_wait);
+		}
+	}
+}
+
+/* Function to Enable/Disable AF Engine */
+int isp_af_enable(int enable)
+{
+	unsigned int pcr;
+
+	pcr = omap_readl(ISPH3A_PCR);
+
+	/* Set AF_EN bit in PCR Register */
+	if (enable) {
+		if (isp_set_callback(CBK_H3A_AF_DONE, isp_af_isr,
+						(void *)NULL, (void *)NULL)) {
+			printk(KERN_ERR "No callback for AF\n");
+			return -EINVAL;
+		}
+
+		pcr |= AF_EN;
+	} else {
+		isp_unset_callback(CBK_H3A_AF_DONE);
+		pcr &= ~AF_EN;
+	}
+	omap_writel(pcr, ISPH3A_PCR);
+	return 0;
+}
+
+/* Function to register the AF character device driver. */
+int __init isp_af_init(void)
+{
+	/*allocate memory for device structure and initialize it with 0 */
+	af_dev_configptr = kzalloc(sizeof(struct af_device), GFP_KERNEL);
+	if (!af_dev_configptr)
+		goto err_nomem1;
+
+	active_buff = NULL;
+
+	af_dev_configptr->config = (struct af_configuration *)
+			kzalloc(sizeof(struct af_configuration), GFP_KERNEL);
+
+	if (af_dev_configptr->config == NULL)
+		goto err_nomem2;
+
+	printk(KERN_DEBUG "isp_af_init\n");
+	memset(&afstat, 0, sizeof(afstat));
+
+	init_waitqueue_head(&afstat.stats_wait);
+	spin_lock_init(&afstat.buffer_lock);
+
+	return 0;
+
+err_nomem2:
+	kfree(af_dev_configptr);
+err_nomem1:
+	printk(KERN_ERR "Error: kmalloc fail");
+	return -ENOMEM;
+}
+
+void __exit isp_af_exit(void)
+{
+	int i;
+
+	if (afstat.af_buff) {
+	/* Free buffers */
+		for (i = 0; i < H3A_MAX_BUFF; i++) {
+			ispmmu_unmap(afstat.af_buff[i].ispmmu_addr);
+			dma_free_coherent(NULL,
+				afstat.min_buf_size + 64,
+				(void *)afstat.af_buff[i].virt_addr,
+				(dma_addr_t)afstat.af_buff[i].phy_addr);
+		}
+	}
+	kfree(af_dev_configptr->config);
+	kfree(af_dev_configptr);
+
+	memset(&afstat, 0, sizeof(afstat));
+
+	af_major = -1;
+	isp_af_enable(0);
+}
diff --git a/drivers/media/video/isp/isp_af.h b/drivers/media/video/isp/isp_af.h
new file mode 100644
index 0000000..34275c9
--- /dev/null
+++ b/drivers/media/video/isp/isp_af.h
@@ -0,0 +1,141 @@
+/*
+ * drivers/media/video/isp/isp_af.h
+ *
+ * Include file for AF module in TI's OMAP3430 Camera ISP
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/* Device Constants */
+#ifndef OMAP_ISP_AF_H
+#define OMAP_ISP_AF_H
+
+#include <asm/arch/isp_user.h>
+
+#define AF_MAJOR_NUMBER			0
+#define ISPAF_NAME			"OMAPISP_AF"
+#define AF_NR_DEVS			1
+#define AF_TIMEOUT			((300 * HZ) / 1000)
+
+/* Range Constants */
+#define AF_IIRSH_MIN			0
+#define AF_IIRSH_MAX			4094
+#define AF_PAXEL_HORIZONTAL_COUNT_MIN	0
+#define AF_PAXEL_HORIZONTAL_COUNT_MAX	35
+#define AF_PAXEL_VERTICAL_COUNT_MIN	0
+#define AF_PAXEL_VERTICAL_COUNT_MAX	127
+#define AF_PAXEL_INCREMENT_MIN		0
+#define AF_PAXEL_INCREMENT_MAX		14
+#define AF_PAXEL_HEIGHT_MIN		0
+#define AF_PAXEL_HEIGHT_MAX		127
+#define AF_PAXEL_WIDTH_MIN		0
+#define AF_PAXEL_WIDTH_MAX		127
+#define AF_PAXEL_HZSTART_MIN		2
+#define AF_PAXEL_HZSTART_MAX		4094
+
+#define AF_PAXEL_VTSTART_MIN		0
+#define AF_PAXEL_VTSTART_MAX		4095
+#define AF_THRESHOLD_MAX		255
+#define AF_COEF_MAX			4095
+#define AF_PAXEL_SIZE			48
+
+/* Print Macros */
+/*list of error code */
+#define AF_ERR_HZ_COUNT			800	/* Invalid Horizontal Count */
+#define AF_ERR_VT_COUNT			801	/* Invalid Vertical Count */
+#define AF_ERR_HEIGHT			802	/* Invalid Height */
+#define AF_ERR_WIDTH			803	/* Invalid width */
+#define AF_ERR_INCR			804	/* Invalid Increment */
+#define AF_ERR_HZ_START			805	/* Invalid horizontal Start */
+#define AF_ERR_VT_START			806	/* Invalud vertical Start */
+#define AF_ERR_IIRSH			807	/* Invalid IIRSH value */
+#define AF_ERR_IIR_COEF			808	/* Invalid Coefficient */
+#define AF_ERR_SETUP			809	/* Setup not done */
+#define AF_ERR_THRESHOLD		810	/* Invalid Threshold */
+#define AF_ERR_ENGINE_BUSY		811	/* Engine is busy */
+
+#define AFPID				0x0	/* Peripheral Revision
+						 * and Class Information
+						 */
+
+#define AFCOEF_OFFSET			0x00000004	/* COEFFICIENT BASE
+							 * ADDRESS
+							 */
+
+/*
+ * PCR fields
+ */
+#define AF_BUSYAF			(1 << 15)
+#define FVMODE				(1 << 14)
+#define RGBPOS				(0x7 << 11)
+#define MED_TH				(0xFF << 3)
+#define AF_MED_EN			(1 << 2)
+#define AF_ALAW_EN			(1 << 1)
+#define AF_EN				(1 << 0)
+
+/*
+ * AFPAX1 fields
+ */
+#define PAXW				(0x7F << 16)
+#define PAXH				0x7F
+
+/*
+ * AFPAX2 fields
+ */
+#define AFINCV				(0xF << 13)
+#define PAXVC				(0x7F << 6)
+#define PAXHC				0x3F
+
+/*
+ * AFPAXSTART fields
+ */
+#define PAXSH				(0xFFF<<16)
+#define PAXSV				0xFFF
+
+/*
+ * COEFFICIENT MASK
+ */
+
+#define COEF_MASK0			0xFFF
+#define COEF_MASK1			(0xFFF<<16)
+
+/* BIT SHIFTS */
+#define AF_RGBPOS_SHIFT			11
+#define AF_MED_TH_SHIFT			3
+#define AF_PAXW_SHIFT			16
+#define AF_LINE_INCR_SHIFT		13
+#define AF_VT_COUNT_SHIFT		6
+#define AF_HZ_START_SHIFT		16
+#define AF_COEF_SHIFT			16
+
+#define AF_UPDATEXS_TS			(1 << 0)
+#define AF_UPDATEXS_FIELDCOUNT	(1 << 1)
+#define AF_UPDATEXS_LENSPOS		(1 << 2)
+
+/* Structure for device of AF Engine */
+struct af_device {
+	struct af_configuration *config; /*Device configuration structure */
+	int size_paxel;		/*Paxel size in bytes */
+};
+
+int isp_af_check_paxel(void);
+int isp_af_check_iir(void);
+int isp_af_register_setup(struct af_device *af_dev);
+int isp_af_enable(int);
+void isp_af_notify(int notify);
+int isp_af_request_statistics(struct isp_af_data *afdata);
+int isp_af_configure(struct af_configuration *afconfig);
+void isp_af_set_address(unsigned long);
+void isp_af_setxtrastats(struct isp_af_xtrastats *xtrastats, u8 updateflag);
+int __init isp_af_init(void);
+void __exit isp_af_exit(void);
+
+#endif	/* OMAP_ISP_AF_H */
diff --git a/drivers/media/video/isp/ispccdc.c b/drivers/media/video/isp/ispccdc.c
index ae46ea7..2986251 100644
--- a/drivers/media/video/isp/ispccdc.c
+++ b/drivers/media/video/isp/ispccdc.c
@@ -304,6 +304,7 @@ copy_from_user_err:
 	printk(KERN_ERR "CCDC Config:Copy From User Error");
 	return -EINVAL ;
 }
+EXPORT_SYMBOL(omap34xx_isp_ccdc_config);
 
 /**
  * ispccdc_request - Reserves the CCDC module.
@@ -443,7 +444,6 @@ void ispccdc_enable_lsc(u8 enable)
 }
 EXPORT_SYMBOL(ispccdc_enable_lsc);
 
-
 /**
  * ispccdc_config_crop - Configures crop parameters for the ISP CCDC.
  * @left: Left offset of the crop area.
@@ -550,9 +550,14 @@ int ispccdc_config_datapath(enum ccdc_input input, enum ccdc_output output)
 		syn_mode &= ~ISPCCDC_SYN_MODE_VP2SDR;
 		syn_mode &= ~ISPCCDC_SYN_MODE_SDR2RSZ;
 		syn_mode |= ISPCCDC_SYN_MODE_WEN;
-		syn_mode |= ISPCCDC_SYN_MODE_EXWEN;
-		omap_writel((omap_readl(ISPCCDC_CFG)) | ISPCCDC_CFG_WENLOG,
-								ISPCCDC_CFG);
+
+		if (input != CCDC_YUV_BT) {
+			syn_mode |= ISPCCDC_SYN_MODE_EXWEN;
+			omap_writel((omap_readl(ISPCCDC_CFG)) |
+					ISPCCDC_CFG_WENLOG,
+					ISPCCDC_CFG);
+		} else
+			syn_mode &= ~ISPCCDC_SYN_MODE_EXWEN;
 		break;
 
 	case CCDC_OTHERS_VP_MEM:
@@ -614,12 +619,28 @@ int ispccdc_config_datapath(enum ccdc_input input, enum ccdc_output output)
 		syncif.hdpol = 0;
 		syncif.ipmod = YUV16;
 		syncif.vdpol = 0;
+		syncif.bt_r656_en = 0;
 		ispccdc_config_imgattr(0);
 		ispccdc_config_sync_if(syncif);
 		blkcfg.dcsubval = 0;
 		ispccdc_config_black_clamp(blkcfg);
 		break;
 	case CCDC_YUV_BT:
+		syncif.ccdc_mastermode = 0;
+		syncif.datapol = 0;
+		syncif.datsz = DAT8;
+		syncif.fldmode = 1;
+		syncif.fldout = 0;
+		syncif.fldpol = 0;
+		syncif.fldstat = 0;
+		syncif.hdpol = 0;
+		syncif.ipmod = YUV8;
+		syncif.vdpol = 1;
+		syncif.bt_r656_en = 1;
+		ispccdc_config_imgattr(0);
+		ispccdc_config_sync_if(syncif);
+		blkcfg.dcsubval = 0;
+		ispccdc_config_black_clamp(blkcfg);
 		break;
 	case CCDC_OTHERS:
 		break;
@@ -630,8 +651,8 @@ int ispccdc_config_datapath(enum ccdc_input input, enum ccdc_output output)
 
 	ispccdc_obj.ccdc_inpfmt = input;
 	ispccdc_obj.ccdc_outfmt = output;
-		ispccdc_print_status();
-		isp_print_status();
+	ispccdc_print_status();
+	isp_print_status();
 	return 0;
 }
 EXPORT_SYMBOL(ispccdc_config_datapath);
@@ -664,6 +685,8 @@ void ispccdc_config_sync_if(struct ispccdc_syncif syncif)
 		break;
 	case YUV8:
 		syn_mode |= ISPCCDC_SYN_MODE_INPMOD_YCBCR8;
+		if (syncif.bt_r656_en)
+			syn_mode |= ISPCCDC_SYN_MODE_PACK8;
 		break;
 	};
 
@@ -728,6 +751,11 @@ void ispccdc_config_sync_if(struct ispccdc_syncif syncif)
 		omap_writel((omap_readl(ISPCCDC_REC656IF)) &
 						~ISPCCDC_REC656IF_R656ON,
 						ISPCCDC_REC656IF);
+	} else {
+		omap_writel((omap_readl(ISPCCDC_REC656IF)) |
+						(ISPCCDC_REC656IF_R656ON |
+						ISPCCDC_REC656IF_ECCFVH),
+						ISPCCDC_REC656IF);
 	}
 }
 EXPORT_SYMBOL(ispccdc_config_sync_if);
@@ -1165,28 +1193,72 @@ int ispccdc_config_size(u32 input_w, u32 input_h, u32 output_w, u32 output_h)
 
 	} else if (ispccdc_obj.ccdc_outfmt == CCDC_OTHERS_MEM) {
 		if (cpu_is_omap3410()) {
-			omap_writel(0 << ISPCCDC_HORZ_INFO_SPH_SHIFT |
+			if (ispccdc_obj.ccdc_inpfmt != CCDC_YUV_BT)
+				omap_writel(0 << ISPCCDC_HORZ_INFO_SPH_SHIFT |
 						((ispccdc_obj.ccdcout_w - 1) <<
 						ISPCCDC_HORZ_INFO_NPH_SHIFT),
 						ISPCCDC_HORZ_INFO);
+			else
+				omap_writel(0 << ISPCCDC_HORZ_INFO_SPH_SHIFT |
+					(((ispccdc_obj.ccdcout_w << 1) - 1) <<
+					ISPCCDC_HORZ_INFO_NPH_SHIFT),
+					ISPCCDC_HORZ_INFO);
 		} else {
-			omap_writel(1 << ISPCCDC_HORZ_INFO_SPH_SHIFT |
+			if (ispccdc_obj.ccdc_inpfmt != CCDC_YUV_BT)
+				omap_writel(1 << ISPCCDC_HORZ_INFO_SPH_SHIFT |
 						((ispccdc_obj.ccdcout_w - 1) <<
 						ISPCCDC_HORZ_INFO_NPH_SHIFT),
 						ISPCCDC_HORZ_INFO);
+			else
+				omap_writel(0 << ISPCCDC_HORZ_INFO_SPH_SHIFT |
+					(((ispccdc_obj.ccdcout_w << 1) - 1) <<
+					ISPCCDC_HORZ_INFO_NPH_SHIFT),
+					ISPCCDC_HORZ_INFO);
 		}
-		omap_writel(0 << ISPCCDC_VERT_START_SLV0_SHIFT,
-							ISPCCDC_VERT_START);
-		omap_writel((ispccdc_obj.ccdcout_h - 1) <<
+
+		if (ispccdc_obj.ccdc_inpfmt != CCDC_YUV_BT) {
+			omap_writel(0 << ISPCCDC_VERT_START_SLV0_SHIFT,
+						ISPCCDC_VERT_START);
+			omap_writel((ispccdc_obj.ccdcout_h - 1) <<
+						ISPCCDC_VERT_LINES_NLV_SHIFT,
+						ISPCCDC_VERT_LINES);
+		} else {
+			omap_writel(2 << ISPCCDC_VERT_START_SLV0_SHIFT |
+					2 << ISPCCDC_VERT_START_SLV1_SHIFT,
+					ISPCCDC_VERT_START);
+			omap_writel(((ispccdc_obj.ccdcout_h >> 1) - 1) <<
 						ISPCCDC_VERT_LINES_NLV_SHIFT,
 						ISPCCDC_VERT_LINES);
+		}
 
 		ispccdc_config_outlineoffset(ispccdc_obj.ccdcout_w * 2, 0, 0);
-		omap_writel((((ispccdc_obj.ccdcout_h - 1) &
+
+		if (ispccdc_obj.ccdc_inpfmt != CCDC_YUV_BT) {
+			omap_writel((((ispccdc_obj.ccdcout_h - 1) &
 					ISPCCDC_VDINT_0_MASK) <<
 					ISPCCDC_VDINT_0_SHIFT) |
 					((50 & ISPCCDC_VDINT_1_MASK) <<
 					ISPCCDC_VDINT_1_SHIFT), ISPCCDC_VDINT);
+		} else {
+			ispccdc_config_outlineoffset(ispccdc_obj.ccdcout_w * 2,
+							EVENEVEN,
+							1);
+			ispccdc_config_outlineoffset(ispccdc_obj.ccdcout_w * 2,
+							ODDEVEN,
+							1);
+			ispccdc_config_outlineoffset(ispccdc_obj.ccdcout_w * 2,
+							EVENODD,
+							1);
+			ispccdc_config_outlineoffset(ispccdc_obj.ccdcout_w * 2,
+							ODDODD,
+							1);
+
+			omap_writel((((0) &
+					ISPCCDC_VDINT_0_MASK) <<
+					ISPCCDC_VDINT_0_SHIFT) |
+					((0 & ISPCCDC_VDINT_1_MASK) <<
+					ISPCCDC_VDINT_1_SHIFT), ISPCCDC_VDINT);
+		}
 	} else if (ispccdc_obj.ccdc_outfmt == CCDC_OTHERS_VP_MEM) {
 		omap_writel((1 << ISPCCDC_FMT_HORZ_FMTSPH_SHIFT) |
 					(ispccdc_obj.ccdcin_w <<
@@ -1332,12 +1404,47 @@ void ispccdc_enable(u8 enable)
 EXPORT_SYMBOL(ispccdc_enable);
 
 /**
+ * ispccdc_config_y8pos - Configures the location of Y color component
+ * @mode: Y8POS_EVEN Y pixel in even position, otherwise Y pixel in odd
+ *
+ * Configures the location of Y color componenent for YCbCr 8-bit data
+ */
+void ispccdc_config_y8pos(enum y8pos_mode mode)
+{
+	if (mode == Y8POS_EVEN)
+		omap_writel(omap_readl(ISPCCDC_CFG) & ~(ISPCCDC_CFG_Y8POS),
+								ISPCCDC_CFG);
+	else
+		omap_writel(omap_readl(ISPCCDC_CFG) | (ISPCCDC_CFG_Y8POS),
+								ISPCCDC_CFG);
+}
+EXPORT_SYMBOL(ispccdc_config_y8pos);
+
+/**
+ * ispccdc_config_byteswap - Configures byte swap data stored in memory
+ * @swap: 1 - swap bytes, 0 - normal
+ *
+ * Controls the order in which the Y and C pixels are stored in memory
+ */
+void ispccdc_config_byteswap(int swap)
+{
+	if (swap)
+		omap_writel(omap_readl(ISPCCDC_CFG) | (ISPCCDC_CFG_BSWD),
+								ISPCCDC_CFG);
+	else
+		omap_writel(omap_readl(ISPCCDC_CFG) & ~(ISPCCDC_CFG_BSWD),
+								ISPCCDC_CFG);
+}
+EXPORT_SYMBOL(ispccdc_config_byteswap);
+
+/**
  * ispccdc_busy - Gets busy state of the CCDC.
  **/
 int ispccdc_busy(void)
 {
 	return omap_readl(ISPCCDC_PCR) & ISPCCDC_PCR_BUSY;
 }
+EXPORT_SYMBOL(ispccdc_busy);
 
 /**
  * ispccdc_save_context - Saves the values of the CCDC module registers
@@ -1449,7 +1556,7 @@ EXPORT_SYMBOL(ispccdc_print_status);
  *
  * Always returns 0
  **/
-static int __init isp_ccdc_init(void)
+int __init isp_ccdc_init(void)
 {
 	ispccdc_obj.ccdc_inuse = 0;
 	ispccdc_config_crop(0, 0, 0, 0);
@@ -1472,7 +1579,7 @@ static int __init isp_ccdc_init(void)
 /**
  * isp_ccdc_cleanup - CCDC module cleanup.
  **/
-static void isp_ccdc_cleanup(void)
+void isp_ccdc_cleanup(void)
 {
 	if (is_isplsc_activated()) {
 		if (lsc_initialized) {
@@ -1487,10 +1594,3 @@ static void isp_ccdc_cleanup(void)
 		kfree(fpc_table_add);
 	}
 }
-
-module_init(isp_ccdc_init);
-module_exit(isp_ccdc_cleanup);
-
-MODULE_AUTHOR("Texas Instruments");
-MODULE_DESCRIPTION("ISP CCDC Library");
-MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/isp/ispccdc.h b/drivers/media/video/isp/ispccdc.h
index 0fd55ee..6c8651b 100644
--- a/drivers/media/video/isp/ispccdc.h
+++ b/drivers/media/video/isp/ispccdc.h
@@ -66,6 +66,11 @@ enum datasize {
 	DAT12
 };
 
+/* Enumeration constants for location of Y component in 8-bit YUV data */
+enum y8pos_mode {
+	Y8POS_EVEN = 0,
+	Y8POS_ODD = 1
+};
 
 /**
  * struct ispccdc_syncif - Structure for Sync Interface between sensor and CCDC
@@ -197,6 +202,10 @@ int ispccdc_set_outaddr(u32 addr);
 
 void ispccdc_enable(u8 enable);
 
+void ispccdc_config_y8pos(enum y8pos_mode mode);
+
+void ispccdc_config_byteswap(int swap);
+
 int ispccdc_busy(void);
 
 void ispccdc_save_context(void);
@@ -207,4 +216,8 @@ void ispccdc_print_status(void);
 
 int omap34xx_isp_ccdc_config(void *userspace_add);
 
+int __init isp_ccdc_init(void);
+
+void __exit isp_ccdc_cleanup(void);
+
 #endif		/* OMAP_ISP_CCDC_H */
diff --git a/drivers/media/video/isp/isph3a.c b/drivers/media/video/isp/isph3a.c
index e4de4fa..1c7d4d3 100644
--- a/drivers/media/video/isp/isph3a.c
+++ b/drivers/media/video/isp/isph3a.c
@@ -580,7 +580,7 @@ static int isph3a_aewb_mmap_buffers(struct isph3a_aewb_buffer *buffer)
 	vma.vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags);
 	vma.vm_pgoff = pgoff;
 	vma.vm_file = NULL;
-	vma.vm_page_prot = protection_map[vma.vm_flags];
+	vma.vm_page_prot = vm_get_page_prot(vma.vm_flags);
 
 	while (size > 0) {
 		if (vm_insert_page(&vma, addr, vmalloc_to_page(pos)))
@@ -822,7 +822,7 @@ EXPORT_SYMBOL(isph3a_aewb_request_statistics);
  *
  * Always returns 0.
  **/
-static int __init isph3a_aewb_init(void)
+int __init isph3a_aewb_init(void)
 {
 	memset(&aewbstat, 0, sizeof(aewbstat));
 	memset(&aewb_regs, 0, sizeof(aewb_regs));
@@ -835,7 +835,7 @@ static int __init isph3a_aewb_init(void)
 /**
  * isph3a_aewb_cleanup - Module exit.
  **/
-static void isph3a_aewb_cleanup(void)
+void __exit isph3a_aewb_cleanup(void)
 {
 	int i;
 	isph3a_aewb_enable(0);
@@ -913,10 +913,3 @@ void isph3a_restore_context(void)
 	isp_restore_context(isph3a_reg_list);
 }
 EXPORT_SYMBOL(isph3a_restore_context);
-
-module_init(isph3a_aewb_init);
-module_exit(isph3a_aewb_cleanup);
-
-MODULE_AUTHOR("Texas Instruments");
-MODULE_DESCRIPTION("H3A ISP Module");
-MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/isp/isph3a.h b/drivers/media/video/isp/isph3a.h
index 6959af6..0aaf293 100644
--- a/drivers/media/video/isp/isph3a.h
+++ b/drivers/media/video/isp/isph3a.h
@@ -53,7 +53,6 @@
 #define MIN_SUB_INC		2
 #define MAX_SUB_INC		32
 
-
 /* ISPH3A REGISTERS bits */
 #define ISPH3A_PCR_AF_EN	(1 << 0)
 #define ISPH3A_PCR_AF_ALAW_EN	(1 << 1)
@@ -136,4 +135,8 @@ void isph3a_restore_context(void);
 
 void isph3a_update_wb(void);
 
+int __init isph3a_aewb_init(void);
+
+void __exit isph3a_aewb_cleanup(void);
+
 #endif		/* OMAP_ISP_H3A_H */
diff --git a/drivers/media/video/isp/isphist.c b/drivers/media/video/isp/isphist.c
index 87823f9..37ddad5 100644
--- a/drivers/media/video/isp/isphist.c
+++ b/drivers/media/video/isp/isphist.c
@@ -446,7 +446,7 @@ static int isp_hist_mmap_buffer(struct isp_hist_buffer *buffer)
 	vma.vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags);
 	vma.vm_pgoff = pgoff;
 	vma.vm_file = NULL;
-	vma.vm_page_prot = protection_map[vma.vm_flags];
+	vma.vm_page_prot = vm_get_page_prot(vma.vm_flags);
 
 	if (vm_insert_page(&vma, addr, vmalloc_to_page(pos)))
 		return -EAGAIN;
@@ -561,7 +561,7 @@ EXPORT_SYMBOL(isp_hist_request_statistics);
  *
  * Returns 0 if successful.
  **/
-static int __init isp_hist_init(void)
+int __init isp_hist_init(void)
 {
 	memset(&histstat, 0, sizeof(histstat));
 	memset(&hist_regs, 0, sizeof(hist_regs));
@@ -572,7 +572,7 @@ static int __init isp_hist_init(void)
 /**
  * isp_hist_cleanup - Module cleanup.
  **/
-static void isp_hist_cleanup(void)
+void __exit isp_hist_cleanup(void)
 {
 	isp_hist_enable(0);
 	mdelay(100);
@@ -597,6 +597,7 @@ isphist_save_context(void)
 	DPRINTK_ISPHIST(" Saving context\n");
 	isp_save_context(isphist_reg_list);
 }
+EXPORT_SYMBOL(isphist_save_context);
 
 /**
  * isphist_restore_context - Restores the values of the histogram module regs.
@@ -607,6 +608,7 @@ isphist_restore_context(void)
 	DPRINTK_ISPHIST(" Restoring context\n");
 	isp_restore_context(isphist_reg_list);
 }
+EXPORT_SYMBOL(isphist_restore_context);
 
 /**
  * isp_hist_print_status - Debug print
@@ -640,12 +642,3 @@ static void isp_hist_print_status(void)
 	DPRINTK_ISPHIST("ISPHIST_H_V_INFO = 0x%08x\n",
 						omap_readl(ISPHIST_H_V_INFO));
 }
-
-module_init(isp_hist_init);
-module_exit(isp_hist_cleanup);
-module_exit(isphist_save_context);
-module_exit(isphist_restore_context);
-
-MODULE_AUTHOR("Texas Instruments");
-MODULE_DESCRIPTION("HISTOGRAM ISP Module");
-MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/isp/isphist.h b/drivers/media/video/isp/isphist.h
index 704e5bf..d9ddc71 100644
--- a/drivers/media/video/isp/isphist.h
+++ b/drivers/media/video/isp/isphist.h
@@ -85,7 +85,6 @@
 		(reg = ((reg & ~ISPHIST_REGVERT_MASK) \
 		| (reg_n_vert & ISPHIST_REGVERT_MASK)))
 
-
 int isp_hist_configure(struct isp_hist_config *histcfg);
 
 int isp_hist_request_statistics(struct isp_hist_data *histdata);
@@ -94,4 +93,8 @@ void isphist_save_context(void);
 
 void isphist_restore_context(void);
 
+int __init isp_hist_init(void);
+
+void __exit isp_hist_cleanup(void);
+
 #endif				/* OMAP_ISP_HIST */
diff --git a/drivers/media/video/isp/ispmmu.c b/drivers/media/video/isp/ispmmu.c
index b231f42..983dea8 100644
--- a/drivers/media/video/isp/ispmmu.c
+++ b/drivers/media/video/isp/ispmmu.c
@@ -562,7 +562,7 @@ static void ispmmu_isr(unsigned long status, isp_vbq_callback_ptr arg1,
  * when no memory for TTB, or init_l2_page_cache return value if L2 page cache
  * init fails.
  **/
-static int __init ispmmu_init(void)
+int __init ispmmu_init(void)
 {
 	int i, val = 0;
 	struct isp_sysc isp_sysconfig;
@@ -661,7 +661,7 @@ static int __init ispmmu_init(void)
 /**
  * ispmmu_cleanup - Frees the L1, L2 Page tables. Unsets the callback for MMU.
  **/
-static void ispmmu_cleanup(void)
+void __exit ispmmu_cleanup(void)
 {
 	ttb = page_address(ttb_page);
 	ttb_p = __pa(ttb);
@@ -733,10 +733,3 @@ void ispmmu_print_status(void)
 						omap_readl(ISPMMU_READ_RAM));
 }
 EXPORT_SYMBOL_GPL(ispmmu_print_status);
-
-MODULE_AUTHOR("Texas Instruments.");
-MODULE_DESCRIPTION("OMAP3430 ISP MMU Driver");
-MODULE_LICENSE("GPL");
-
-module_init(ispmmu_init);
-module_exit(ispmmu_cleanup);
diff --git a/drivers/media/video/isp/ispmmu.h b/drivers/media/video/isp/ispmmu.h
index f5c729f..3828eaa 100644
--- a/drivers/media/video/isp/ispmmu.h
+++ b/drivers/media/video/isp/ispmmu.h
@@ -114,4 +114,8 @@ void ispmmu_save_context(void);
 
 void ispmmu_restore_context(void);
 
+int __init ispmmu_init(void);
+
+void __exit ispmmu_cleanup(void);
+
 #endif /* OMAP_ISP_MMU_H */
diff --git a/drivers/media/video/isp/isppreview.c b/drivers/media/video/isp/isppreview.c
index 5baeae2..2d70557 100644
--- a/drivers/media/video/isp/isppreview.c
+++ b/drivers/media/video/isp/isppreview.c
@@ -96,20 +96,20 @@ static struct ispprev_csc flr_prev_csc[] = {
 			{0x0, 0x0, 0x0}
 	},
 	{
-		{	/* CSC Coef Matrix BW*/
-			{66, 129, 25},
+		{	/* CSC Coef Matrix Sepia */
+			{19, 38, 7},
 			{0, 0, 0},
 			{0, 0, 0}
 		},	/* CSC Offset */
-			{0x0, 0x0, 0x0}
+			{0x0, 0xE7, 0x14}
 	},
 	{
-		{	/* CSC Coef Matrix Sepia*/
+		{	/* CSC Coef Matrix BW */
 			{66, 129, 25},
 			{0, 0, 0},
 			{0, 0, 0}
 		},	/* CSC Offset */
-			{0x0, 0xE7, 0x14}
+			{0x0, 0x0, 0x0}
 	}
 };
 
@@ -429,6 +429,7 @@ err_copy_from_user:
 	printk(KERN_ERR "Preview Config: Copy From User Error");
 	return -EINVAL;
 }
+EXPORT_SYMBOL(omap34xx_isp_preview_config);
 
 /**
  * omap34xx_isp_tables_update - Abstraction layer Tables update.
@@ -1287,6 +1288,7 @@ void isppreview_query_contrast(u8 *contrast)
 	*contrast = (brt_cnt_val >> ISPPRV_CNT_BRT_CNT_SHIFT) & 0xFF;
 	DPRINTK_ISPPREV(" Current brt cnt value in hw is %x\n", brt_cnt_val);
 }
+EXPORT_SYMBOL(isppreview_query_contrast);
 
 /**
  * isppreview_update_contrast - Updates the contrast.
@@ -1298,6 +1300,7 @@ void isppreview_update_contrast(u8 *contrast)
 {
 	ispprev_obj.contrast = *contrast;
 }
+EXPORT_SYMBOL(isppreview_update_contrast);
 
 /**
  * isppreview_config_contrast - Configures the Contrast.
@@ -1338,6 +1341,7 @@ void isppreview_update_brightness(u8 *brightness)
 {
 	ispprev_obj.brightness = *brightness;
 }
+EXPORT_SYMBOL(isppreview_update_brightness);
 
 /**
  * isppreview_config_brightness - Configures the brightness.
@@ -1364,6 +1368,7 @@ void isppreview_query_brightness(u8 *brightness)
 
 	*brightness = omap_readl(ISPPRV_CNT_BRT);
 }
+EXPORT_SYMBOL(isppreview_query_brightness);
 
 /**
  * isppreview_get_brightness_range - Gets the range brightness value
@@ -1785,7 +1790,7 @@ EXPORT_SYMBOL(isppreview_print_status);
 /**
  * isp_preview_init - Module Initialization.
  **/
-static int __init isp_preview_init(void)
+int __init isp_preview_init(void)
 {
 	int i = 0;
 
@@ -1799,11 +1804,11 @@ static int __init isp_preview_init(void)
 	ispprev_obj.prev_inuse = 0;
 	mutex_init(&ispprev_obj.ispprev_mutex);
 
-	if (is_sil_rev_greater_than(OMAP3430_REV_ES1_0)) {
+	if (is_sil_rev_equal_to(OMAP3430_REV_ES2_0)) {
 		flr_wbal_coef0 = 0x23;
 		flr_wbal_coef1 = 0x20;
 		flr_wbal_coef2 = 0x20;
-		flr_wbal_coef3 = 0x30;
+		flr_wbal_coef3 = 0x39;
 	}
 
 	/* Init values */
@@ -1856,15 +1861,8 @@ static int __init isp_preview_init(void)
 /**
  * isp_preview_cleanup - Module Cleanup.
  **/
-static void isp_preview_cleanup(void)
+void __exit isp_preview_cleanup(void)
 {
 	kfree(prev_config_params);
 	prev_config_params = NULL;
 }
-
-module_init(isp_preview_init);
-module_exit(isp_preview_cleanup);
-
-MODULE_AUTHOR("Texas Instruments");
-MODULE_DESCRIPTION("ISP Preview Library");
-MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/isp/isppreview.h b/drivers/media/video/isp/isppreview.h
index 48c7b08..a811227 100644
--- a/drivers/media/video/isp/isppreview.h
+++ b/drivers/media/video/isp/isppreview.h
@@ -59,7 +59,6 @@
 #define PREV_DARK_FRAME_CAPTURE		(1 << 10)
 #define PREV_DEFECT_COR			(1 << 11)
 
-
 #define ISP_NF_TABLE_SIZE 		(1 << 10)
 
 #define ISP_GAMMA_TABLE_SIZE 		(1 << 10)
@@ -95,7 +94,6 @@ enum preview_color_effect {
 	PREV_SEPIA_COLOR = 2
 };
 
-
 /**
  * struct ispprev_gtable - Structure for Gamma Correction.
  * @redtable: Pointer to the red gamma table.
@@ -259,7 +257,6 @@ void isppreview_enable_dcor(u8 enable);
 
 void isppreview_config_dcor(struct ispprev_dcor prev_dcor);
 
-
 void isppreview_config_cfa(struct ispprev_cfa);
 
 void isppreview_config_gammacorrn(struct ispprev_gtable);
@@ -346,4 +343,8 @@ int omap34xx_isp_preview_config(void *userspace_add);
 
 int omap34xx_isp_tables_update(struct isptables_update *isptables_struct);
 
+int __init isp_preview_init(void);
+
+void __exit isp_preview_cleanup(void);
+
 #endif/* OMAP_ISP_PREVIEW_H */
diff --git a/drivers/media/video/isp/ispresizer.c b/drivers/media/video/isp/ispresizer.c
index 8f84dc4..d83fc3d 100644
--- a/drivers/media/video/isp/ispresizer.c
+++ b/drivers/media/video/isp/ispresizer.c
@@ -188,6 +188,7 @@ void ispresizer_trycrop(u32 left, u32 top, u32 width, u32 height, u32 ow,
 	ispres_obj.ipht_crop = top;
 	ispres_obj.ipwd_crop = left;
 }
+EXPORT_SYMBOL(ispresizer_trycrop);
 
 /**
  * ispresizer_applycrop - Apply crop to input image.
@@ -199,6 +200,7 @@ void ispresizer_applycrop()
 						ispres_obj.outputheight);
 	return;
 }
+EXPORT_SYMBOL(ispresizer_applycrop);
 
 /**
  * ispresizer_request - Reserves the Resizer module.
@@ -559,6 +561,7 @@ int ispresizer_config_size(u32 input_w, u32 input_h, u32 output_w,
 						v_filter_coef_4tap[j + 1] <<
 						ISPRSZ_VFILT10_COEF1_SHIFT),
 						ISPRSZ_VFILT10 + (i * 0x04));
+			j += 2;
 		}
 	} else {
 		j = 0;
@@ -618,6 +621,7 @@ int ispresizer_busy(void)
 	return omap_readl(ISPRSZ_PCR) & ISPPRV_PCR_BUSY;
 }
 EXPORT_SYMBOL(ispresizer_busy);
+
 /**
  * ispresizer_config_startphase - Sets the horizontal and vertical start phase.
  * @hstartphase: horizontal start phase (0 - 7).
@@ -841,7 +845,7 @@ EXPORT_SYMBOL(ispresizer_print_status);
  *
  * Always returns 0.
  **/
-static int __init isp_resizer_init(void)
+int __init isp_resizer_init(void)
 {
 	mutex_init(&ispres_obj.ispres_mutex);
 	return 0;
@@ -850,13 +854,6 @@ static int __init isp_resizer_init(void)
 /**
  * isp_resizer_cleanup - Module Cleanup.
  **/
-static void isp_resizer_cleanup(void)
+void __exit isp_resizer_cleanup(void)
 {
 }
-
-module_init(isp_resizer_init);
-module_exit(isp_resizer_cleanup);
-
-MODULE_AUTHOR("Texas Instruments");
-MODULE_DESCRIPTION("ISP Resizer Library");
-MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/isp/ispresizer.h b/drivers/media/video/isp/ispresizer.h
index e66df2b..5de9722 100644
--- a/drivers/media/video/isp/ispresizer.h
+++ b/drivers/media/video/isp/ispresizer.h
@@ -150,4 +150,8 @@ void ispresizer_restore_context(void);
 
 void ispresizer_print_status(void);
 
+int __init isp_resizer_init(void);
+
+void __exit isp_resizer_cleanup(void);
+
 #endif		/* OMAP_ISP_RESIZER_H */
diff --git a/drivers/media/video/isp/omap_previewer.c b/drivers/media/video/isp/omap_previewer.c
index 529ebb0..d276b4a 100644
--- a/drivers/media/video/isp/omap_previewer.c
+++ b/drivers/media/video/isp/omap_previewer.c
@@ -782,8 +782,9 @@ static int __init omap_previewer_init(void)
 	if (!prev_class)
 		goto fail4;
 
-	prev_dev = device_create(prev_class, prev_dev, (MKDEV(prev_major, 0)),
-				OMAP_PREV_NAME);
+	prev_dev = device_create_drvdata(prev_class, prev_dev,
+						(MKDEV(prev_major, 0)), NULL,
+						OMAP_PREV_NAME);
 	dev_dbg(prev_dev, OMAP_PREV_NAME ": Registered Previewer Wrapper\n");
 	device->opened = 0;
 
diff --git a/drivers/media/video/omap34xxcam.c b/drivers/media/video/omap34xxcam.c
index 0f38bf7..27cf98c 100644
--- a/drivers/media/video/omap34xxcam.c
+++ b/drivers/media/video/omap34xxcam.c
@@ -99,6 +99,19 @@ out:
 }
 
 /**
+ * omap34xxcam_configure_std - Sets buffer format and standard
+ * @vdev: ptr. to per-device camera information data structure
+ * @std: Detected standard
+ *
+ * Sets the buffer format and standard depending on the detected standard
+ */
+static int omap34xxcam_configure_std(struct omap34xxcam_videodev *vdev,
+							v4l2_std_id std)
+{
+	return isp_configure_std(std);
+}
+
+/**
  * omap34xxcam_update_vbq - Updates VBQ with completed input buffer
  * @vb: ptr. to standard V4L2 video buffer structure
  *
@@ -142,7 +155,6 @@ static int omap34xxcam_vbq_setup(struct videobuf_queue *vbq, unsigned int *cnt,
 				 unsigned int *size)
 {
 	struct omap34xxcam_fh *fh = vbq->priv_data;
-	struct v4l2_format format;
 
 	if (*cnt <= 0)
 		*cnt = VIDEO_MAX_FRAME;	/* supply a default number of buffers */
@@ -150,8 +162,7 @@ static int omap34xxcam_vbq_setup(struct videobuf_queue *vbq, unsigned int *cnt,
 	if (*cnt > VIDEO_MAX_FRAME)
 		*cnt = VIDEO_MAX_FRAME;
 
-	isp_g_fmt_cap(&format);
-	*size = format.fmt.pix.sizeimage;
+	*size = fh->pix.sizeimage;
 
 	/* accessing fh->cam->capture_mem is ok, it's constant */
 	while (*size * *cnt > fh->vdev->capture_mem)
@@ -194,20 +205,19 @@ static int omap34xxcam_vbq_prepare(struct videobuf_queue *vbq,
 				   struct videobuf_buffer *vb,
 				   enum v4l2_field field)
 {
-	struct v4l2_format format;
+	struct omap34xxcam_fh *fh = vbq->priv_data;
 	unsigned int size;
 	int err = 0;
 
-	isp_g_fmt_cap(&format);
-	size = format.fmt.pix.sizeimage;
+	size = fh->pix.sizeimage;
 	/*
 	 * Accessing pix here is okay since it's constant while
 	 * streaming is on (and we only get called then).
 	 */
 	if (vb->baddr) {
 		/* This is a userspace buffer. */
-		if (size > vb->bsize)
-			/* The buffer isn't big enough. */
+		if ((size > vb->bsize) || vb->baddr != (vb->baddr & ~0x1F))
+			/* The buffer isn't big enough/not aligned to 32 byte */
 			err = -EINVAL;
 		else {
 			vb->size = size;
@@ -238,8 +248,8 @@ static int omap34xxcam_vbq_prepare(struct videobuf_queue *vbq,
 	if (err)
 		return err;
 
-	vb->width = format.fmt.pix.width;
-	vb->height = format.fmt.pix.height;
+	vb->width = fh->pix.width;
+	vb->height = fh->pix.height;
 	vb->field = field;
 
 	if (vb->state == VIDEOBUF_NEEDS_INIT) {
@@ -342,7 +352,9 @@ static int vidioc_enum_fmt_cap(struct file *file, void *fh,
 	struct omap34xxcam_videodev *vdev = ofh->vdev;
 	int rval;
 
-	if (vdev->vdev_sensor_config.sensor_isp)
+	if (vdev->vdev_sensor_mode)
+		return isp_enum_fmt_cap(f);
+	else if (vdev->vdev_sensor_config.sensor_isp)
 		rval = vidioc_int_enum_fmt_cap(vdev->vdev_sensor, f);
 	else
 		rval = isp_enum_fmt_cap(f);
@@ -365,7 +377,10 @@ static int vidioc_g_fmt_cap(struct file *file, void *fh, struct v4l2_format *f)
 	struct omap34xxcam_videodev *vdev = ofh->vdev;
 
 	mutex_lock(&vdev->mutex);
-	f->fmt.pix = ofh->pix;
+	if (vdev->vdev_sensor_mode)
+		isp_g_fmt_cap(&f->fmt.pix);
+	else
+		f->fmt.pix = ofh->pix;
 	mutex_unlock(&vdev->mutex);
 
 	return 0;
@@ -386,6 +401,7 @@ static int vidioc_s_fmt_cap(struct file *file, void *fh, struct v4l2_format *f)
 	struct omap34xxcam_videodev *vdev = ofh->vdev;
 	struct v4l2_pix_format *pix = &f->fmt.pix;
 	struct v4l2_pix_format pix_tmp;
+	struct v4l2_format input_fmt = *f;
 	int rval;
 
 	mutex_lock(&vdev->mutex);
@@ -394,22 +410,42 @@ static int vidioc_s_fmt_cap(struct file *file, void *fh, struct v4l2_format *f)
 		goto out;
 	}
 
-	pix_tmp.width = f->fmt.pix.width;
-	pix_tmp.height = f->fmt.pix.height;
-	pix_tmp.pixelformat = f->fmt.pix.pixelformat;
-	/* Always negotiate with the sensor first */
-	rval = vidioc_int_s_fmt_cap(vdev->vdev_sensor, f);
-	if (rval)
-		goto out;
+	if (vdev->vdev_sensor_mode) {
+		rval = isp_check_format(pix);
+		if (rval)
+			goto out;
+
+		pix_tmp = f->fmt.pix;
+		/* Always negotiate with the sensor first */
+		rval = vidioc_int_s_fmt_cap(vdev->vdev_sensor, &input_fmt);
+		if (rval)
+			goto out;
+
+		pix->pixelformat = input_fmt.fmt.pix.pixelformat;
+		pix->field = input_fmt.fmt.pix.field;
+		pix->colorspace = input_fmt.fmt.pix.colorspace;
+	} else {
+		pix_tmp.width = f->fmt.pix.width;
+		pix_tmp.height = f->fmt.pix.height;
+		pix_tmp.pixelformat = f->fmt.pix.pixelformat;
+		/* Always negotiate with the sensor first */
+		rval = vidioc_int_s_fmt_cap(vdev->vdev_sensor, f);
+		if (rval)
+			goto out;
+	}
 
 	/* Negotiate with OMAP3 ISP */
 	rval = isp_s_fmt_cap(pix, &pix_tmp);
+	if (!rval)
+		isp_g_fmt_cap(&pix_tmp);
 out:
+	if (!rval)
+		ofh->pix = pix_tmp;
 	mutex_unlock(&vdev->mutex);
 
 	if (!rval) {
 		mutex_lock(&ofh->vbq.vb_lock);
-		*pix = ofh->pix = pix_tmp;
+		*pix = pix_tmp;
 		mutex_unlock(&ofh->vbq.vb_lock);
 	}
 
@@ -431,19 +467,42 @@ static int vidioc_try_fmt_cap(struct file *file, void *fh,
 	struct omap34xxcam_fh *ofh = fh;
 	struct omap34xxcam_videodev *vdev = ofh->vdev;
 	struct v4l2_pix_format *pix = &f->fmt.pix;
-	struct v4l2_pix_format pix_tmp;
+	struct v4l2_pix_format pix_tmp, pix_out;
 	int rval;
+	struct v4l2_format input_fmt = *f;
 
 	mutex_lock(&vdev->mutex);
-	pix_tmp.width = f->fmt.pix.width;
-	pix_tmp.height = f->fmt.pix.height;
-	pix_tmp.pixelformat = f->fmt.pix.pixelformat;
-	rval = vidioc_int_try_fmt_cap(vdev->vdev_sensor, f);
-	if (rval)
-		goto out;
+	if (vdev->vdev_sensor_mode) {
+		rval = isp_check_format(pix);
+		if (rval) {
+			mutex_unlock(&vdev->mutex);
+			return vidioc_g_fmt_cap(file, fh, f);
+		}
+
+		pix_out = f->fmt.pix;
+
+		/* Always negotiate with decoder for pixel format and field */
+		rval = vidioc_int_try_fmt_cap(vdev->vdev_sensor, &input_fmt);
+		if (rval)
+			goto out;
+
+		pix->pixelformat = input_fmt.fmt.pix.pixelformat;
+		pix->field = input_fmt.fmt.pix.field;
+		pix->colorspace = input_fmt.fmt.pix.colorspace;
+
+		rval = isp_try_fmt_cap(pix, &pix_out);
+		*pix = pix_out;
+	} else {
+		pix_tmp.width = f->fmt.pix.width;
+		pix_tmp.height = f->fmt.pix.height;
+		pix_tmp.pixelformat = f->fmt.pix.pixelformat;
+		rval = vidioc_int_try_fmt_cap(vdev->vdev_sensor, f);
+		if (rval)
+			goto out;
 
-	rval = isp_try_fmt_cap(pix, &pix_tmp);
-	*pix = pix_tmp;
+		rval = isp_try_fmt_cap(pix, &pix_tmp);
+		*pix = pix_tmp;
+	}
 
 out:
 	mutex_unlock(&vdev->mutex);
@@ -565,12 +624,6 @@ static int vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type i)
 		dev_dbg(vdev->cam->dev, "omap34xxcam_slave_power_set failed\n");
 		goto out;
 	}
-	/* Configure sensor and start streaming */
-	rval = vidioc_int_init(vdev->vdev_sensor);
-	if (rval) {
-		dev_dbg(vdev->cam->dev, "vidioc_int_init failed\n");
-		goto out;
-	}
 
 	cam->dma_notify = 1;
 	isp_sgdma_init();
@@ -602,16 +655,19 @@ static int vidioc_streamoff(struct file *file, void *fh, enum v4l2_buf_type i)
 	struct videobuf_queue *q = &ofh->vbq;
 	int rval;
 
-	isp_stop();
+	mutex_lock(&vdev->mutex);
+
+	if (vdev->streaming == file)
+		isp_stop();
+
 	rval = videobuf_streamoff(q);
-	if (!rval) {
-		mutex_lock(&vdev->mutex);
+	if (!rval)
 		vdev->streaming = NULL;
-		mutex_unlock(&vdev->mutex);
-	}
 
 	omap34xxcam_slave_power_set(vdev, V4L2_POWER_STANDBY);
 
+	mutex_unlock(&vdev->mutex);
+
 	return rval;
 }
 
@@ -626,13 +682,24 @@ static int vidioc_streamoff(struct file *file, void *fh, enum v4l2_buf_type i)
 static int vidioc_enum_input(struct file *file, void *fh,
 			     struct v4l2_input *inp)
 {
-	if (inp->index > 0)
-		return -EINVAL;
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	int rval = 0;
 
-	strlcpy(inp->name, "camera", sizeof(inp->name));
-	inp->type = V4L2_INPUT_TYPE_CAMERA;
+	mutex_lock(&vdev->mutex);
+	if (vdev->vdev_sensor_mode)
+		rval = vidioc_int_enum_input(vdev->vdev_sensor, inp);
+	else {
+		if (inp->index > 0)
+			rval = -EINVAL;
+		else {
+			strlcpy(inp->name, "camera", sizeof(inp->name));
+			inp->type = V4L2_INPUT_TYPE_CAMERA;
+		}
+	}
+	mutex_unlock(&vdev->mutex);
 
-	return 0;
+	return rval;
 }
 
 /**
@@ -645,9 +712,19 @@ static int vidioc_enum_input(struct file *file, void *fh,
  */
 static int vidioc_g_input(struct file *file, void *fh, unsigned int *i)
 {
-	*i = 0;
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	int rval = 0;
 
-	return 0;
+	mutex_lock(&vdev->mutex);
+	if (vdev->vdev_sensor_mode)
+		rval = vidioc_int_g_input(vdev->vdev_sensor, i);
+	else
+		*i = 0;
+
+	mutex_unlock(&vdev->mutex);
+
+	return rval;
 }
 
 /**
@@ -660,10 +737,20 @@ static int vidioc_g_input(struct file *file, void *fh, unsigned int *i)
  */
 static int vidioc_s_input(struct file *file, void *fh, unsigned int i)
 {
-	if (i > 0)
-		return -EINVAL;
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	int rval = 0;
 
-	return 0;
+	mutex_lock(&vdev->mutex);
+	if (vdev->vdev_sensor_mode)
+		rval = vidioc_int_s_input(vdev->vdev_sensor, i);
+	else {
+		if (i > 0)
+			rval = -EINVAL;
+	}
+	mutex_unlock(&vdev->mutex);
+
+	return rval;
 }
 
 /**
@@ -729,6 +816,9 @@ static int vidioc_g_ctrl(struct file *file, void *fh, struct v4l2_control *a)
 		/* If control not supported on ISP, try sensor */
 		if (rval)
 			rval = vidioc_int_g_ctrl(vdev->vdev_sensor, a);
+		/* If control not supported on sensor, try lens */
+		if (rval)
+			rval = vidioc_int_g_ctrl(vdev->vdev_lens, a);
 	}
 	mutex_unlock(&vdev->mutex);
 
@@ -763,6 +853,9 @@ static int vidioc_s_ctrl(struct file *file, void *fh, struct v4l2_control *a)
 		/* If control not supported on ISP, try sensor */
 		if (rval)
 			rval = vidioc_int_s_ctrl(vdev->vdev_sensor, a);
+		/* If control not supported on sensor, try lens */
+		if (rval)
+			rval = vidioc_int_s_ctrl(vdev->vdev_lens, a);
 	}
 	mutex_unlock(&vdev->mutex);
 
@@ -853,6 +946,8 @@ static int vidioc_cropcap(struct file *file, void *fh, struct v4l2_cropcap *a)
 	struct v4l2_cropcap *cropcap = a;
 	int rval;
 
+	mutex_lock(&vdev->mutex);
+
 	if (vdev->vdev_sensor_config.sensor_isp) {
 		rval = vidioc_int_cropcap(vdev->vdev_sensor, a);
 	} else {
@@ -864,6 +959,9 @@ static int vidioc_cropcap(struct file *file, void *fh, struct v4l2_cropcap *a)
 		cropcap->pixelaspect.denominator = 1;
 		rval = 0;
 	}
+
+	mutex_unlock(&vdev->mutex);
+
 	return rval;
 }
 
@@ -882,11 +980,15 @@ static int vidioc_g_crop(struct file *file, void *fh, struct v4l2_crop *a)
 	struct omap34xxcam_videodev *vdev = ofh->vdev;
 	int rval = 0;
 
+	mutex_lock(&vdev->mutex);
+
 	if (vdev->vdev_sensor_config.sensor_isp)
 		rval = vidioc_int_g_crop(vdev->vdev_sensor, a);
 	else
 		rval = isp_g_crop(a);
 
+	mutex_unlock(&vdev->mutex);
+
 	return rval;
 }
 
@@ -906,11 +1008,161 @@ static int vidioc_s_crop(struct file *file, void *fh, struct v4l2_crop *a)
 	struct v4l2_pix_format *pix = &ofh->pix;
 	int rval = 0;
 
+	mutex_lock(&vdev->mutex);
+
 	if (vdev->vdev_sensor_config.sensor_isp)
 		rval = vidioc_int_s_crop(vdev->vdev_sensor, a);
 	else
 		rval = isp_s_crop(a, pix);
 
+	mutex_unlock(&vdev->mutex);
+
+	return rval;
+}
+
+/**
+ * vidioc_default - private IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @cmd: ioctl cmd value
+ * @arg: ioctl arg value
+ *
+ * If the sensor being used is a "smart sensor", this request is returned to
+ * caller with -EINVAL err code.  Otherwise if the control id is the private
+ * VIDIOC_PRIVATE_ISP_AEWB_REQ to update the analog gain or exposure,
+ * then this request is forwared directly to the sensor to incorporate the
+ * feedback. The request is then passed on to the ISP private IOCTL handler,
+ * isp_handle_private()
+ */
+static int vidioc_default(struct file *file, void *fh, int cmd, void *arg)
+{
+	struct omap34xxcam_fh *ofh = file->private_data;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	int rval;
+
+	if (vdev->vdev_sensor_config.sensor_isp) {
+		rval = -EINVAL;
+	} else {
+		switch (cmd) {
+		case VIDIOC_PRIVATE_ISP_AEWB_REQ:
+		{
+			/* Need to update sensor first */
+			struct isph3a_aewb_data *data;
+			struct v4l2_control vc;
+
+			data = (struct isph3a_aewb_data *) arg;
+			if (data->update & SET_EXPOSURE) {
+				vc.id = V4L2_CID_EXPOSURE;
+				vc.value = data->shutter;
+				mutex_lock(&vdev->mutex);
+				rval = vidioc_int_s_ctrl(vdev->vdev_sensor,
+							 &vc);
+				mutex_unlock(&vdev->mutex);
+				if (rval)
+					goto out;
+			}
+			if (data->update & SET_ANALOG_GAIN) {
+				vc.id = V4L2_CID_GAIN;
+				vc.value = data->gain;
+				mutex_lock(&vdev->mutex);
+				rval = vidioc_int_s_ctrl(vdev->vdev_sensor,
+							 &vc);
+				mutex_unlock(&vdev->mutex);
+				if (rval)
+					goto out;
+			}
+		}
+		break;
+		case VIDIOC_PRIVATE_ISP_AF_CFG: {
+			/* Need to update lens first */
+			struct isp_af_data *data;
+			struct v4l2_control vc;
+
+			data = (struct isp_af_data *) arg;
+			if (data->update & LENS_DESIRED_POSITION) {
+				vc.id = V4L2_CID_FOCUS_ABSOLUTE;
+				vc.value = data->desired_lens_direction;
+				mutex_lock(&vdev->mutex);
+				rval = vidioc_int_s_ctrl(vdev->vdev_lens, &vc);
+				mutex_unlock(&vdev->mutex);
+				if (rval)
+					goto out;
+			}
+			if (data->update & REQUEST_STATISTICS) {
+				vc.id = V4L2_CID_FOCUS_ABSOLUTE;
+				mutex_lock(&vdev->mutex);
+				rval = vidioc_int_g_ctrl(vdev->vdev_lens, &vc);
+				mutex_unlock(&vdev->mutex);
+				if (rval)
+					goto out;
+				data->xtrastats.lens_position = vc.value;
+			}
+		}
+		break;
+		}
+
+		rval = isp_handle_private(cmd, arg);
+	}
+out:
+	mutex_unlock(&vdev->mutex);
+	return rval;
+}
+
+/**
+ * vidioc_querystd - V4L2 query current standard IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @std: standard V4L2 v4l2_std_id enum
+ *
+ * If using a "smart" sensor, just forwards request to the sensor driver,
+ * otherwise returns error
+ */
+static int vidioc_querystd(struct file *file, void *fh, v4l2_std_id *std)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	int rval = 0;
+
+	mutex_lock(&vdev->mutex);
+	if (vdev->vdev_sensor_mode) {
+		rval = vidioc_int_querystd(vdev->vdev_sensor, std);
+		if (rval == 0) {
+			vdev->vfd->current_norm = *std;
+			rval = omap34xxcam_configure_std(vdev, *std);
+		}
+	} else
+		rval = -EINVAL;
+	mutex_unlock(&vdev->mutex);
+
+	return rval;
+}
+
+/**
+ * vidioc_s_std - V4L2 set standard IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @std: standard V4L2 v4l2_std_id enum
+ *
+ * If using a "smart" sensor, just forwards request to the sensor driver,
+ * otherwise returns error
+ */
+static int vidioc_s_std(struct file *file, void *fh, v4l2_std_id *std)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	int rval = 0;
+
+	mutex_lock(&vdev->mutex);
+	if (vdev->vdev_sensor_mode) {
+		rval = vidioc_int_s_std(vdev->vdev_sensor, std);
+		if (rval == 0) {
+			vdev->vfd->current_norm = *std;
+			rval = omap34xxcam_configure_std(vdev, *std);
+		}
+	} else
+		rval = -EINVAL;
+	mutex_unlock(&vdev->mutex);
+
 	return rval;
 }
 
@@ -920,6 +1172,12 @@ static int vidioc_s_crop(struct file *file, void *fh, struct v4l2_crop *a)
  *
  */
 
+static long omap34xxcam_unlocked_ioctl(struct file *file, unsigned int cmd,
+				       unsigned long arg)
+{
+	return (long)video_ioctl2(file->f_dentry->d_inode, file, cmd, arg);
+}
+
 /**
  * omap34xxcam_poll - file operations poll handler
  * @file: ptr. to system file structure
@@ -1019,25 +1277,19 @@ static int omap34xxcam_open(struct inode *inode, struct file *file)
 	if (atomic_inc_return(&vdev->users) == 1) {
 		isp_get();
 		isp_open();
-		if (omap34xxcam_slave_power_set(vdev, V4L2_POWER_ON)) {
-			mutex_unlock(&vdev->mutex);
-			goto out_try_module_get;
-		}
-		if (omap34xxcam_slave_power_set(vdev, V4L2_POWER_STANDBY)) {
-			mutex_unlock(&vdev->mutex);
-			goto out_try_module_get;
-		}
+		if (omap34xxcam_slave_power_set(vdev, V4L2_POWER_ON))
+			goto out_slave_power_set_standby;
+		if (omap34xxcam_slave_power_set(vdev, V4L2_POWER_STANDBY))
+			goto out_slave_power_set_standby;
 	}
 
-	mutex_unlock(&vdev->mutex);
 	fh->vdev = vdev;
-	mutex_lock(&vdev->mutex);
 
 	/* FIXME: Check that we have sensor now... */
 	if (vdev->vdev_sensor_config.sensor_isp)
 		vidioc_int_g_fmt_cap(vdev->vdev_sensor, &format);
 	else
-		isp_g_fmt_cap(&format);
+		isp_g_fmt_cap(&format.fmt.pix);
 
 	mutex_unlock(&vdev->mutex);
 	/* FIXME: how about fh->pix when there are more users? */
@@ -1054,13 +1306,18 @@ static int omap34xxcam_open(struct inode *inode, struct file *file)
 
 	return 0;
 
+out_slave_power_set_standby:
+	omap34xxcam_slave_power_set(vdev, V4L2_POWER_OFF);
+	isp_close();
+	isp_put();
+	atomic_dec(&vdev->users);
+	mutex_unlock(&vdev->mutex);
+
 out_try_module_get:
 	for (i--; i >= 0; i--)
 		if (vdev->slave[i])
 			module_put(vdev->slave[i]->module);
 
-	isp_close();
-	isp_put();
 	kfree(fh);
 
 	return -ENODEV;
@@ -1111,84 +1368,6 @@ static int omap34xxcam_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
-/**
- * omap34xxcam_handle_private - private IOCTL handler
- * @inode: ptr. to system inode structure
- * @file: ptr. to system file structure
- * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
- * @cmd: ioctl cmd value
- * @arg: ioctl arg value
- *
- * If the sensor being used is a "smart sensor", this request is returned to
- * caller with -EINVAL err code.  Otherwise if the control id is the private
- * VIDIOC_PRIVATE_ISP_AEWB_REQ to update the analog gain or exposure,
- * then this request is forwared directly to the sensor to incorporate the
- * feedback. The request is then passed on to the ISP private IOCTL handler,
- * isp_handle_private()
- */
-static int omap34xxcam_handle_private(struct file *file, void *fh,
-							int cmd, void *arg)
-{
-	struct omap34xxcam_fh *ofh = file->private_data;
-	struct omap34xxcam_videodev *vdev = ofh->vdev;
-	int rval;
-
-	mutex_lock(&vdev->mutex);
-
-	if (vdev->vdev_sensor_config.sensor_isp) {
-		rval = -EINVAL;
-	} else {
-		switch (cmd) {
-		case VIDIOC_PRIVATE_ISP_AEWB_REQ:
-		{
-			/* Need to update sensor first */
-			struct isph3a_aewb_data *data;
-			struct v4l2_control vc;
-
-			data = (struct isph3a_aewb_data *) arg;
-			if (data->update & SET_EXPOSURE) {
-				vc.id = V4L2_CID_EXPOSURE;
-				vc.value = data->shutter;
-				rval = vidioc_int_s_ctrl(vdev->vdev_sensor,
-							 &vc);
-				if (rval)
-					goto out;
-			}
-			if (data->update & SET_ANALOG_GAIN) {
-				vc.id = V4L2_CID_GAIN;
-				vc.value = data->gain;
-				rval = vidioc_int_s_ctrl(vdev->vdev_sensor,
-							 &vc);
-				if (rval)
-					goto out;
-			}
-		}
-		default:
-			rval = isp_handle_private(cmd, arg);
-		}
-	}
-out:
-	mutex_unlock(&vdev->mutex);
-	return rval;
-}
-
-/**
- * omap34xxcam_unlocked_ioctl - unlocked (unserialized) IOCTL handler
- * @file: ptr. to system file structure
- * @cmd: ioctl cmd value
- * @arg: ioctl arg value
- *
- * Unlocked (unserialized) ioctl handler for the camera driver.
- * Checks if the IOCTL is in the private ioctl range, and if so
- * calls the local private ioctl handler omap34xxcam_handle_private(),
- * otherwise it calls the V4L2 provided ioctl handler (video_ioctl2).
- */
-static long omap34xxcam_unlocked_ioctl(struct file *file, unsigned int cmd,
-							unsigned long arg)
-{
-	return (long)video_ioctl2(file->f_dentry->d_inode, file, cmd, arg);
-}
-
 static struct file_operations omap34xxcam_fops = {
 	.owner = THIS_MODULE,
 	.llseek = no_llseek,
@@ -1255,6 +1434,8 @@ static int omap34xxcam_device_register(struct v4l2_int_device *s)
 	struct omap34xxcam_hw_config hwc;
 	struct video_device *vfd;
 	int rval, i;
+	struct v4l2_ifparm ifparm;
+	enum v4l2_if_type_bt656_mode mode;
 
 	/* We need to check rval just once. The place is here. */
 	if (vidioc_int_g_priv(s, &hwc))
@@ -1320,7 +1501,11 @@ static int omap34xxcam_device_register(struct v4l2_int_device *s)
 		vfd->vidioc_cropcap	 = vidioc_cropcap;
 		vfd->vidioc_g_crop	 = vidioc_g_crop;
 		vfd->vidioc_s_crop	 = vidioc_s_crop;
-		vfd->vidioc_default	 = omap34xxcam_handle_private;
+		vfd->vidioc_default	 = vidioc_default;
+		vfd->vidioc_s_std	 = vidioc_s_std;
+		vfd->vidioc_querystd	 = vidioc_querystd;
+		vfd->current_norm	 = V4L2_STD_NTSC;
+		vfd->tvnorms		 = V4L2_STD_NTSC | V4L2_STD_PAL;
 
 		if (video_register_device(vfd, VFL_TYPE_GRABBER,
 					  hwc.dev_minor) < 0) {
@@ -1336,6 +1521,17 @@ static int omap34xxcam_device_register(struct v4l2_int_device *s)
 		vfd = vdev->vfd;
 	}
 
+	/* Determine whether the slave connected is BT656 decoder or a sensor */
+	vdev->slave_mode[hwc.dev_type] = 0;
+	if (!vidioc_int_g_ifparm(s, &ifparm)) {
+		if (ifparm.if_type == V4L2_IF_TYPE_BT656) {
+			mode = ifparm.u.bt656.mode;
+			if ((mode == V4L2_IF_TYPE_BT656_MODE_BT_8BIT) ||
+				(mode == V4L2_IF_TYPE_BT656_MODE_BT_10BIT))
+				vdev->slave_mode[hwc.dev_type] = 1;
+		}
+	}
+
 	vdev->slaves++;
 	vdev->slave[hwc.dev_type] = s;
 	vdev->slave_config[hwc.dev_type] = hwc;
@@ -1343,8 +1539,10 @@ static int omap34xxcam_device_register(struct v4l2_int_device *s)
 		 s->name, hwc.dev_type, vfd->minor);
 
 	isp_get();
+	isp_open();
 	rval = omap34xxcam_slave_power_set(vdev, V4L2_POWER_ON);
 	omap34xxcam_slave_power_set(vdev, V4L2_POWER_OFF);
+	isp_close();
 	isp_put();
 
 	if (rval)
@@ -1510,6 +1708,7 @@ static int omap34xxcam_probe(struct platform_device *pdev)
 	isp_sysconfig.reset = 0;
 	isp_sysconfig.idle_mode = 1;
 	isp_power_settings(isp_sysconfig);
+	isp_put();
 
 	for (i = 0; i < OMAP34XXCAM_VIDEODEVS; i++) {
 		struct omap34xxcam_videodev *vdev = &cam->vdevs[i];
@@ -1521,23 +1720,21 @@ static int omap34xxcam_probe(struct platform_device *pdev)
 		m->u.master     = &omap34xxcam_master;
 		m->priv		= vdev;
 
-		if (v4l2_int_device_register(m))
-			goto err;
-
 		mutex_init(&vdev->mutex);
 		vdev->index             = i;
 		vdev->cam               = cam;
 		vdev->capture_mem       = capture_mem;
+
+		if (v4l2_int_device_register(m))
+			goto err;
 	}
 
 	omap34xxcam = cam;
-	isp_put();
 
 	return 0;
 
 err:
 	omap34xxcam_remove(pdev);
-	isp_put();
 	return -ENODEV;
 }
 
@@ -1560,8 +1757,6 @@ static int omap34xxcam_remove(struct platform_device *pdev)
 
 	omap34xxcam = NULL;
 
-	isp_put();
-
 	for (i = 0; i < OMAP34XXCAM_VIDEODEVS; i++) {
 		if (cam->vdevs[i].cam == NULL)
 			continue;
diff --git a/drivers/media/video/omap34xxcam.h b/drivers/media/video/omap34xxcam.h
index 30d14d2..c799ae1 100644
--- a/drivers/media/video/omap34xxcam.h
+++ b/drivers/media/video/omap34xxcam.h
@@ -125,6 +125,10 @@ struct omap34xxcam_videodev {
 #define vdev_lens_config slave_config[OMAP34XXCAM_SLAVE_LENS].u.lens
 #define vdev_flash_config slave_config[OMAP34XXCAM_SLAVE_FLASH].u.flash
 	struct omap34xxcam_hw_config slave_config[OMAP34XXCAM_SLAVE_FLASH + 1];
+#define vdev_sensor_mode slave_mode[OMAP34XXCAM_SLAVE_SENSOR]
+#define vdev_lens_mode slave_mode[OMAP34XXCAM_SLAVE_LENS]
+#define vdev_flash_mode slave_mode[OMAP34XXCAM_SLAVE_FLASH]
+	int slave_mode[OMAP34XXCAM_SLAVE_FLASH + 1];
 
 	/*** capture data ***/
 	/* file handle, if streaming is on */
diff --git a/drivers/media/video/tvp5146.c b/drivers/media/video/tvp5146.c
new file mode 100644
index 0000000..5788679
--- /dev/null
+++ b/drivers/media/video/tvp5146.c
@@ -0,0 +1,1319 @@
+/*
+ * drivers/media/video/tvp5146.c
+ *
+ * TI TVP5146 decoder driver
+ *
+ * Copyright (C) 2008 Texas Instruments Inc
+ *
+ * Contributors:
+ *     Brijesh R Jadav <brijesh.j@ti.com>
+ *     Hardik Shah <hardik.shah@ti.com>
+ *     Manjunath Hadli <mrh@ti.com>
+ *     Sivaraj R <sivaraj@ti.com>
+ *     Vaibhav Hiremath <hvaibhav@ti.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-int-device.h>
+#include "tvp5146.h"
+
+#define MODULE_NAME	TVP5146_MODULE_NAME
+
+/* Debug functions */
+#ifdef DEBUG
+
+#define dump_reg(client, reg, val)					\
+	do {								\
+		tvp5146_read_reg(client, reg, &val);			\
+		dev_dbg(&(client)->dev, "Reg(0x%.2X): 0x%.2X\n", reg, val); \
+	} while (0)
+
+#endif				/* #ifdef DEBUG */
+
+/* list of image formats supported by tvp5146 decoder */
+static const struct v4l2_fmtdesc tvp5146_fmt_list[] = {
+	{
+	 .index = 0,
+	 .type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
+	 .flags = 0,
+	 .description = "8-bit UYVY 4:2:2 Format",
+	 .pixelformat = V4L2_PIX_FMT_UYVY,
+	 }
+};
+
+#define TVP5146_NUM_FORMATS		ARRAY_SIZE(tvp5146_fmt_list)
+
+/*
+ * Supported standards - These must be ordered according to enum tvp5146_std
+ * order.
+ */
+static struct tvp5146_std_info tvp5146_std_list[] = {
+	{
+	 .width = NTSC_NUM_ACTIVE_PIXELS,
+	 .height = NTSC_NUM_ACTIVE_LINES,
+	 .video_std = VIDEO_STD_NTSC_MJ_BIT,
+	 .standard = {
+		      .index = 0,
+		      .id = V4L2_STD_NTSC,
+		      .name = "NTSC",
+		      .frameperiod = {1001, 30000},
+		      .framelines = 525}
+	 },
+	{
+	 .width = PAL_NUM_ACTIVE_PIXELS,
+	 .height = PAL_NUM_ACTIVE_LINES,
+	 .video_std = VIDEO_STD_PAL_BDGHIN_BIT,
+	 .standard = {
+		      .index = 1,
+		      .id = V4L2_STD_PAL,
+		      .name = "PAL",
+		      .frameperiod = {1, 25},
+		      .framelines = 625}
+	 }
+};
+
+#define TVP5146_NUM_STANDARDS		ARRAY_SIZE(tvp5146_std_list)
+
+/* Supported controls */
+static const struct tvp5146_ctrl_info tvp5146_ctrl_list[] = {
+	{
+	 .reg_address = REG_BRIGHTNESS,
+	 .query_ctrl = {
+			.id = V4L2_CID_BRIGHTNESS,
+			.name = "BRIGHTNESS",
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.minimum = 0,
+			.maximum = 255,
+			.step = 1,
+			.default_value = 128}
+	 },
+	{
+	 .reg_address = REG_CONTRAST,
+	 .query_ctrl = {
+			.id = V4L2_CID_CONTRAST,
+			.name = "CONTRAST",
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.minimum = 0,
+			.maximum = 255,
+			.step = 1,
+			.default_value = 128}
+	 },
+	{
+	 .reg_address = REG_SATURATION,
+	 .query_ctrl = {
+			.id = V4L2_CID_SATURATION,
+			.name = "SATURATION",
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.minimum = 0,
+			.maximum = 255,
+			.step = 1,
+			.default_value = 128}
+	 },
+	{
+	 .reg_address = REG_HUE,
+	 .query_ctrl = {
+			.id = V4L2_CID_HUE,
+			.name = "HUE",
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.minimum = -180,
+			.maximum = 180,
+			.step = 180,
+			.default_value = 0}
+	 },
+	{
+	 .reg_address = REG_AFE_GAIN_CTRL,
+	 .query_ctrl = {
+			.id = V4L2_CID_AUTOGAIN,
+			.name = "Automatic Gain Control",
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 1}
+	 }
+};
+
+#define TVP5146_NUM_CONTROLS		ARRAY_SIZE(tvp5146_ctrl_list)
+
+/*
+ * Read a value from a register in an tvp5146 decoder device.
+ * The value is returned in 'val'.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int tvp5146_read_reg(struct i2c_client *client, u8 reg, u8 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	u8 data;
+
+	if (!client->adapter)
+		return -ENODEV;
+
+	/* [MSG1] fill the register address data */
+	data = reg;
+	msg[0].addr = client->addr;
+	msg[0].len = 1;
+	msg[0].flags = 0;
+	msg[0].buf = &data;
+
+	/* [MSG2] fill the data rx buffer */
+	msg[1].addr = client->addr;
+	msg[1].len = 1;		/* only 1 byte */
+	msg[1].flags = I2C_M_RD;	/* Read the register values */
+	msg[1].buf = val;
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err >= 0)
+		return 0;
+
+	dev_err(&client->dev,
+		"read from device 0x%.2x, offset 0x%.2x error %d\n",
+		client->addr, reg, err);
+
+	return err;
+}
+
+/*
+ * Write a value to a register in an tvp5146 decoder device.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int tvp5146_write_reg(struct i2c_client *client, u8 reg, u8 val)
+{
+	int err;
+	int retry = 0;
+	struct i2c_msg msg[1];
+	u8 data[2];
+
+	if (!client->adapter)
+		return -ENODEV;
+
+again:
+	data[0] = reg;		/* Register offset */
+	data[1] = val;		/* Register value */
+	msg->addr = client->addr;
+	msg->len = 2;
+	msg->flags = 0;		/* write operation */
+	msg->buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 1);
+	if (err >= 0)
+		return 0;
+
+	dev_err(&client->dev,
+		"wrote 0x%.2x to offset 0x%.2x error %d\n", val, reg, err);
+	if (retry <= I2C_RETRY_COUNT) {
+		dev_info(&client->dev, "retry ... %d\n", retry);
+		retry++;
+		schedule_timeout(msecs_to_jiffies(20));
+		goto again;
+	}
+	return err;
+}
+
+/*
+ * tvp5146_write_regs : Initializes a list of TVP5146 registers
+ *		if token is TOK_TERM, then entire write operation terminates
+ *		if token is TOK_DELAY, then a delay of 'val' msec is introduced
+ *		if token is TOK_SKIP, then the register write is skipped
+ *		if token is TOK_WRITE, then the register write is performed
+ *
+ * reglist - list of registers to be written
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int tvp5146_write_regs(struct i2c_client *client,
+			      const struct tvp5146_reg reglist[])
+{
+	int err;
+	const struct tvp5146_reg *next = reglist;
+
+	for (; next->token != TOK_TERM; next++) {
+		if (next->token == TOK_DELAY) {
+			schedule_timeout(msecs_to_jiffies(next->val));
+			continue;
+		}
+
+		if (next->token == TOK_SKIP)
+			continue;
+
+		err = tvp5146_write_reg(client, next->reg, (u8) next->val);
+		if (err) {
+			dev_err(&client->dev, "write failed. Err[%d]\n",
+				err);
+			return err;
+		}
+	}
+	return 0;
+}
+
+/*
+ * tvp5146_get_current_std:
+ * Returns the current standard detected by TVP5146
+ */
+static enum tvp5146_std tvp5146_get_current_std(struct tvp5146_decoder
+						*decoder)
+{
+	u8 std, std_status;
+
+	if (tvp5146_read_reg(decoder->client, REG_VIDEO_STD, &std))
+		return STD_INVALID;
+
+	if ((std & VIDEO_STD_MASK) == VIDEO_STD_AUTO_SWITCH_BIT) {
+		/* use the standard status register */
+		if (tvp5146_read_reg(decoder->client, REG_VIDEO_STD_STATUS,
+				     &std_status))
+			return STD_INVALID;
+	} else
+		std_status = std;	/* use the standard register itself */
+
+	switch (std_status & VIDEO_STD_MASK) {
+	case VIDEO_STD_NTSC_MJ_BIT:
+		return STD_NTSC_MJ;
+		break;
+
+	case VIDEO_STD_PAL_BDGHIN_BIT:
+		return STD_PAL_BDGHIN;
+		break;
+
+	default:
+		return STD_INVALID;
+		break;
+	}
+
+	return STD_INVALID;
+}
+
+#ifdef DEBUG
+/*
+ * TVP5146 register dump function
+ */
+void tvp5146_reg_dump(struct tvp5146_decoder *decoder)
+{
+	u8 value;
+
+	dump_reg(decoder->client, REG_INPUT_SEL, value);
+	dump_reg(decoder->client, REG_AFE_GAIN_CTRL, value);
+	dump_reg(decoder->client, REG_VIDEO_STD, value);
+	dump_reg(decoder->client, REG_OPERATION_MODE, value);
+	dump_reg(decoder->client, REG_COLOR_KILLER, value);
+	dump_reg(decoder->client, REG_LUMA_CONTROL1, value);
+	dump_reg(decoder->client, REG_LUMA_CONTROL2, value);
+	dump_reg(decoder->client, REG_LUMA_CONTROL3, value);
+	dump_reg(decoder->client, REG_BRIGHTNESS, value);
+	dump_reg(decoder->client, REG_CONTRAST, value);
+	dump_reg(decoder->client, REG_SATURATION, value);
+	dump_reg(decoder->client, REG_HUE, value);
+	dump_reg(decoder->client, REG_CHROMA_CONTROL1, value);
+	dump_reg(decoder->client, REG_CHROMA_CONTROL2, value);
+	dump_reg(decoder->client, REG_COMP_PR_SATURATION, value);
+	dump_reg(decoder->client, REG_COMP_Y_CONTRAST, value);
+	dump_reg(decoder->client, REG_COMP_PB_SATURATION, value);
+	dump_reg(decoder->client, REG_COMP_Y_BRIGHTNESS, value);
+	dump_reg(decoder->client, REG_AVID_START_PIXEL_LSB, value);
+	dump_reg(decoder->client, REG_AVID_START_PIXEL_MSB, value);
+	dump_reg(decoder->client, REG_AVID_STOP_PIXEL_LSB, value);
+	dump_reg(decoder->client, REG_AVID_STOP_PIXEL_MSB, value);
+	dump_reg(decoder->client, REG_HSYNC_START_PIXEL_LSB, value);
+	dump_reg(decoder->client, REG_HSYNC_START_PIXEL_MSB, value);
+	dump_reg(decoder->client, REG_HSYNC_STOP_PIXEL_LSB, value);
+	dump_reg(decoder->client, REG_HSYNC_STOP_PIXEL_MSB, value);
+	dump_reg(decoder->client, REG_VSYNC_START_LINE_LSB, value);
+	dump_reg(decoder->client, REG_VSYNC_START_LINE_MSB, value);
+	dump_reg(decoder->client, REG_VSYNC_STOP_LINE_LSB, value);
+	dump_reg(decoder->client, REG_VSYNC_STOP_LINE_MSB, value);
+	dump_reg(decoder->client, REG_VBLK_START_LINE_LSB, value);
+	dump_reg(decoder->client, REG_VBLK_START_LINE_MSB, value);
+	dump_reg(decoder->client, REG_VBLK_STOP_LINE_LSB, value);
+	dump_reg(decoder->client, REG_VBLK_STOP_LINE_MSB, value);
+	dump_reg(decoder->client, REG_SYNC_CONTROL, value);
+	dump_reg(decoder->client, REG_OUTPUT_FORMATTER1, value);
+	dump_reg(decoder->client, REG_OUTPUT_FORMATTER2, value);
+	dump_reg(decoder->client, REG_OUTPUT_FORMATTER3, value);
+	dump_reg(decoder->client, REG_OUTPUT_FORMATTER4, value);
+	dump_reg(decoder->client, REG_OUTPUT_FORMATTER5, value);
+	dump_reg(decoder->client, REG_OUTPUT_FORMATTER6, value);
+	dump_reg(decoder->client, REG_CLEAR_LOST_LOCK, value);
+}
+#endif
+
+/*
+ * Configure the tvp5146 with the current register settings
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int tvp5146_configure(struct tvp5146_decoder *decoder)
+{
+	int err;
+
+	/* common register initialization */
+	err =
+	    tvp5146_write_regs(decoder->client, decoder->pdata->reg_list);
+	if (err)
+		return err;
+
+#ifdef DEBUG
+	tvp5146_reg_dump(decoder);
+#endif
+
+	return 0;
+}
+
+/*
+ * Detect if an tvp5146 is present, and if so which revision.
+ * A device is considered to be detected if the chip ID (LSB and MSB)
+ * registers match the expected values.
+ * Any value of the rom version register is accepted.
+ * Returns ENODEV error number if no device is detected, or zero
+ * if a device is detected.
+ */
+static int tvp5146_detect(struct tvp5146_decoder *decoder)
+{
+	u8 chip_id_msb, chip_id_lsb, rom_ver;
+
+	if (tvp5146_read_reg
+	    (decoder->client, REG_CHIP_ID_MSB, &chip_id_msb))
+		return -ENODEV;
+	if (tvp5146_read_reg
+	    (decoder->client, REG_CHIP_ID_LSB, &chip_id_lsb))
+		return -ENODEV;
+	if (tvp5146_read_reg(decoder->client, REG_ROM_VERSION, &rom_ver))
+		return -ENODEV;
+
+	dev_info(&decoder->client->dev,
+		 "chip id detected msb:0x%x lsb:0x%x rom version:0x%x\n",
+		 chip_id_msb, chip_id_lsb, rom_ver);
+	if ((chip_id_msb != TVP5146_CHIP_ID_MSB)
+		|| (chip_id_lsb != TVP5146_CHIP_ID_LSB)) {
+		/* We didn't read the values we expected, so this must not be
+		 * an TVP5146.
+		 */
+		dev_err(&decoder->client->dev,
+			"chip id mismatch msb:0x%x lsb:0x%x\n",
+			chip_id_msb, chip_id_lsb);
+		return -ENODEV;
+	}
+
+	decoder->ver = rom_ver;
+	decoder->state = STATE_DETECTED;
+
+	return 0;
+}
+
+/*
+ * following are decoder interface functions implemented by
+ * tvp5146 decoder driver.
+ */
+
+/**
+ * ioctl_querystd - V4L2 decoder interface handler for VIDIOC_QUERYSTD ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @std_id: standard V4L2 std_id ioctl enum
+ *
+ * Returns the current standard detected by TVP5146. If no active input is
+ * detected, returns -EINVAL
+ */
+static int ioctl_querystd(struct v4l2_int_device *s, v4l2_std_id *std_id)
+{
+	struct tvp5146_decoder *decoder = s->priv;
+	enum tvp5146_std current_std;
+	u8 sync_lock_status, lock_mask;
+
+	if (std_id == NULL)
+		return -EINVAL;
+
+	/* get the current standard */
+	current_std = tvp5146_get_current_std(decoder);
+	if (current_std == STD_INVALID)
+		return -EINVAL;
+
+	/* check whether signal is locked */
+	if (tvp5146_read_reg
+	    (decoder->client, REG_STATUS1, &sync_lock_status))
+		return -EINVAL;
+
+	lock_mask =
+	    decoder->pdata->input_list[decoder->inputidx].lock_mask;
+	if (lock_mask != (sync_lock_status & lock_mask))
+		return -EINVAL;	/* No input detected */
+
+	decoder->current_std = current_std;
+	*std_id = decoder->std_list[current_std].standard.id;
+
+	return 0;
+}
+
+/**
+ * ioctl_s_std - V4L2 decoder interface handler for VIDIOC_S_STD ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @std_id: standard V4L2 v4l2_std_id ioctl enum
+ *
+ * If std_id is supported, sets the requested standard. Otherwise, returns
+ * -EINVAL
+ */
+static int ioctl_s_std(struct v4l2_int_device *s, v4l2_std_id *std_id)
+{
+	struct tvp5146_decoder *decoder = s->priv;
+	int err, i;
+
+	if (std_id == NULL)
+		return -EINVAL;
+
+	for (i = 0; i < decoder->num_stds; i++)
+		if (*std_id & decoder->std_list[i].standard.id)
+			break;
+
+	if (i == decoder->num_stds)
+		return -EINVAL;
+
+	err = tvp5146_write_reg(decoder->client, REG_VIDEO_STD,
+				decoder->std_list[i].video_std);
+	if (err)
+		return err;
+
+	decoder->current_std = i;
+	decoder->pdata->reg_list[REG_VIDEO_STD].val =
+	    decoder->std_list[i].video_std;
+
+	return 0;
+}
+
+/**
+ * ioctl_enum_input - V4L2 decoder interface handler for VIDIOC_ENUMINPUT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @input: standard V4L2 VIDIOC_ENUMINPUT ioctl structure
+ *
+ * If index is valid, returns the description of the input. Otherwise, returns
+ * -EINVAL if any error occurs
+ */
+static int
+ioctl_enum_input(struct v4l2_int_device *s, struct v4l2_input *input)
+{
+	struct tvp5146_decoder *decoder = s->priv;
+	int index;
+
+	if (input == NULL)
+		return -EINVAL;
+
+	index = input->index;
+	if ((index >= decoder->pdata->num_inputs) || (index < 0))
+		return -EINVAL;	/* Index out of bound */
+
+	memcpy(input, &decoder->pdata->input_list[index].input,
+		sizeof(struct v4l2_input));
+
+	return 0;
+}
+
+/**
+ * ioctl_s_input - V4L2 decoder interface handler for VIDIOC_S_INPUT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @index: number of the input
+ *
+ * If index is valid, selects the requested input. Otherwise, returns -EINVAL if
+ * the input is not supported or there is no active signal present in the
+ * selected input.
+ */
+static int ioctl_s_input(struct v4l2_int_device *s, int index)
+{
+	struct tvp5146_decoder *decoder = s->priv;
+	u8 input_sel;
+	int err;
+	enum tvp5146_std current_std = STD_INVALID;
+	u8 sync_lock_status, lock_mask;
+	int try_count = LOCK_RETRY_COUNT;
+
+	if ((index >= decoder->pdata->num_inputs) || (index < 0))
+		return -EINVAL;	/* Index out of bound */
+
+	/* Get the register value to be written to select the requested input */
+	input_sel = decoder->pdata->input_list[index].input_sel;
+	err = tvp5146_write_reg(decoder->client, REG_INPUT_SEL, input_sel);
+	if (err)
+		return err;
+
+	decoder->inputidx = index;
+	decoder->pdata->reg_list[REG_INPUT_SEL].val = input_sel;
+
+	/* Clear status */
+	msleep(LOCK_RETRY_DELAY);
+	err =
+	    tvp5146_write_reg(decoder->client, REG_CLEAR_LOST_LOCK, 0x01);
+	if (err)
+		return err;
+
+	while (try_count-- > 0) {
+		/* Allow decoder to sync up with new input */
+		msleep(LOCK_RETRY_DELAY);
+
+		/* get the current standard for future reference */
+		current_std = tvp5146_get_current_std(decoder);
+		if (current_std == STD_INVALID)
+			continue;
+
+		if (tvp5146_read_reg(decoder->client, REG_STATUS1,
+					&sync_lock_status))
+			return -EINVAL;
+
+		lock_mask =
+		    decoder->pdata->input_list[decoder->inputidx].
+		    lock_mask;
+		if (lock_mask == (sync_lock_status & lock_mask))
+			break;	/* Input detected */
+	}
+
+	if ((current_std == STD_INVALID) || (try_count < 0))
+		return -EINVAL;
+
+	decoder->current_std = current_std;
+
+	return 0;
+}
+
+/**
+ * ioctl_g_input - V4L2 decoder interface handler for VIDIOC_G_INPUT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @index: returns the current selected input
+ *
+ * Returns the current selected input. Returns -EINVAL if any error occurs
+ */
+static int ioctl_g_input(struct v4l2_int_device *s, int *index)
+{
+	struct tvp5146_decoder *decoder = s->priv;
+	int err = -EINVAL, i, inputidx;
+
+	if (index == NULL)
+		return -EINVAL;
+
+	/* Search through the input list for active inputs */
+	inputidx = decoder->inputidx;
+	for (i = 0; i < decoder->pdata->num_inputs; i++) {
+		inputidx++;	/* Move to next input */
+		if (inputidx >= decoder->pdata->num_inputs)
+			inputidx = 0;	/* fall back to first input */
+
+		err = ioctl_s_input(s, inputidx);
+		if (!err) {
+			/* Active input found - select it and return success */
+			*index = inputidx;
+			return 0;
+		}
+	}
+
+	return err;
+}
+
+/**
+ * ioctl_queryctrl - V4L2 decoder interface handler for VIDIOC_QUERYCTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @qc: standard V4L2 VIDIOC_QUERYCTRL ioctl structure
+ *
+ * If the requested control is supported, returns the control information
+ * from the ctrl_list[] array. Otherwise, returns -EINVAL if the
+ * control is not supported.
+ */
+static int
+ioctl_queryctrl(struct v4l2_int_device *s, struct v4l2_queryctrl *qctrl)
+{
+	struct tvp5146_decoder *decoder = s->priv;
+	int id, index;
+	const struct tvp5146_ctrl_info *control = NULL;
+
+	if (qctrl == NULL)
+		return -EINVAL;
+
+	id = qctrl->id;
+	memset(qctrl, 0, sizeof(struct v4l2_queryctrl));
+	qctrl->id = id;
+
+	for (index = 0; index < decoder->num_ctrls; index++) {
+		control = &decoder->ctrl_list[index];
+		if (control->query_ctrl.id == qctrl->id)
+			break;	/* Match found */
+	}
+	if (index == decoder->num_ctrls)
+		return -EINVAL;	/* Index out of bound */
+
+	memcpy(qctrl, &control->query_ctrl, sizeof(struct v4l2_queryctrl));
+
+	return 0;
+}
+
+/**
+ * ioctl_g_ctrl - V4L2 decoder interface handler for VIDIOC_G_CTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @vc: standard V4L2 VIDIOC_G_CTRL ioctl structure
+ *
+ * If the requested control is supported, returns the control's current
+ * value from the decoder. Otherwise, returns -EINVAL if the control is not
+ * supported.
+ */
+static int
+ioctl_g_ctrl(struct v4l2_int_device *s, struct v4l2_control *ctrl)
+{
+	struct tvp5146_decoder *decoder = s->priv;
+	int err, index;
+	u8 val;
+	int value;
+	const struct tvp5146_ctrl_info *control = NULL;
+
+	if (ctrl == NULL)
+		return -EINVAL;
+
+	for (index = 0; index < decoder->num_ctrls; index++) {
+		control = &decoder->ctrl_list[index];
+		if (control->query_ctrl.id == ctrl->id)
+			break;	/* Match found */
+	}
+	if (index == decoder->num_ctrls)
+		return -EINVAL;	/* Index out of bound */
+
+	err =
+	    tvp5146_read_reg(decoder->client, control->reg_address, &val);
+	if (err < 0)
+		return err;
+
+	/* cross check */
+	if (val != decoder->pdata->reg_list[control->reg_address].val)
+		return -EINVAL;	/* Driver & TVP5146 setting mismatch */
+
+	value = val;
+	if (V4L2_CID_AUTOGAIN == ctrl->id) {
+		if ((value & 0x3) == 3)
+			value = 1;
+		else
+			value = 0;
+	}
+
+	if (V4L2_CID_HUE == ctrl->id) {
+		if (value == 0x7F)
+			value = 180;
+		else if (value == 0x80)
+			value = -180;
+		else
+			value = 0;
+	}
+
+	ctrl->value = value;
+
+	return err;
+}
+
+/**
+ * ioctl_s_ctrl - V4L2 decoder interface handler for VIDIOC_S_CTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @vc: standard V4L2 VIDIOC_S_CTRL ioctl structure
+ *
+ * If the requested control is supported, sets the control's current
+ * value in HW. Otherwise, returns -EINVAL if the control is not supported.
+ */
+static int
+ioctl_s_ctrl(struct v4l2_int_device *s, struct v4l2_control *ctrl)
+{
+	struct tvp5146_decoder *decoder = s->priv;
+	int err, value, index;
+	const struct tvp5146_ctrl_info *control = NULL;
+
+	if (ctrl == NULL)
+		return -EINVAL;
+
+	value = (__s32) ctrl->value;
+	for (index = 0; index < decoder->num_ctrls; index++) {
+		control = &decoder->ctrl_list[index];
+		if (control->query_ctrl.id == ctrl->id)
+			break;	/* Match found */
+	}
+	if (index == decoder->num_ctrls)
+		return -EINVAL;	/* Index out of bound */
+
+	if (V4L2_CID_AUTOGAIN == ctrl->id) {
+		if (value == 1)
+			value = 0x0F;
+		else if (value == 0)
+			value = 0x0C;
+		else
+			return -ERANGE;
+	} else if (V4L2_CID_HUE == ctrl->id) {
+		if (value == 180)
+			value = 0x7F;
+		else if (value == -180)
+			value = 0x80;
+		else if (value == 0)
+			value = 0;
+		else
+			return -ERANGE;
+	} else {
+		if ((value < control->query_ctrl.minimum)
+			|| (value > control->query_ctrl.maximum))
+			return -ERANGE;
+	}
+
+	err =
+	    tvp5146_write_reg(decoder->client, control->reg_address,
+				value);
+	if (err < 0)
+		return err;
+
+	decoder->pdata->reg_list[control->reg_address].val = value;
+	return err;
+}
+
+/**
+ * ioctl_enum_fmt_cap - Implement the CAPTURE buffer VIDIOC_ENUM_FMT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @fmt: standard V4L2 VIDIOC_ENUM_FMT ioctl structure
+ *
+ * Implement the VIDIOC_ENUM_FMT ioctl to enumerate supported formats
+ */
+static int
+ioctl_enum_fmt_cap(struct v4l2_int_device *s, struct v4l2_fmtdesc *fmt)
+{
+	struct tvp5146_decoder *decoder = s->priv;
+	int index;
+
+	if (fmt == NULL)
+		return -EINVAL;
+
+	index = fmt->index;
+	if ((index >= decoder->num_fmts) || (index < 0))
+		return -EINVAL;	/* Index out of bound */
+
+	if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;	/* only capture is supported */
+
+	memcpy(fmt, &decoder->fmt_list[index],
+		sizeof(struct v4l2_fmtdesc));
+
+	return 0;
+}
+
+/**
+ * ioctl_try_fmt_cap - Implement the CAPTURE buffer VIDIOC_TRY_FMT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @f: pointer to standard V4L2 VIDIOC_TRY_FMT ioctl structure
+ *
+ * Implement the VIDIOC_TRY_FMT ioctl for the CAPTURE buffer type. This
+ * ioctl is used to negotiate the image capture size and pixel format
+ * without actually making it take effect.
+ */
+static int
+ioctl_try_fmt_cap(struct v4l2_int_device *s, struct v4l2_format *f)
+{
+	struct tvp5146_decoder *decoder = s->priv;
+	int ifmt;
+	struct v4l2_pix_format *pix;
+	enum tvp5146_std current_std;
+
+	if (f == NULL)
+		return -EINVAL;
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		f->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	pix = &f->fmt.pix;
+
+	/* Calculate height and width based on current standard */
+	current_std = tvp5146_get_current_std(decoder);
+	if (current_std == STD_INVALID)
+		return -EINVAL;
+
+	decoder->current_std = current_std;
+	pix->width = decoder->std_list[current_std].width;
+	pix->height = decoder->std_list[current_std].height;
+
+	for (ifmt = 0; ifmt < decoder->num_fmts; ifmt++) {
+		if (pix->pixelformat ==
+			decoder->fmt_list[ifmt].pixelformat)
+			break;
+	}
+	if (ifmt == decoder->num_fmts)
+		ifmt = 0;	/* None of the format matched, select default */
+	pix->pixelformat = decoder->fmt_list[ifmt].pixelformat;
+
+	pix->field = V4L2_FIELD_INTERLACED;
+	pix->bytesperline = pix->width * 2;
+	pix->sizeimage = pix->bytesperline * pix->height;
+	pix->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	pix->priv = 0;
+
+	return 0;
+}
+
+/**
+ * ioctl_s_fmt_cap - V4L2 decoder interface handler for VIDIOC_S_FMT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @f: pointer to standard V4L2 VIDIOC_S_FMT ioctl structure
+ *
+ * If the requested format is supported, configures the HW to use that
+ * format, returns error code if format not supported or HW can't be
+ * correctly configured.
+ */
+static int
+ioctl_s_fmt_cap(struct v4l2_int_device *s, struct v4l2_format *f)
+{
+	struct tvp5146_decoder *decoder = s->priv;
+	struct v4l2_pix_format *pix;
+	int rval;
+
+	if (f == NULL)
+		return -EINVAL;
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;	/* only capture is supported */
+
+	pix = &f->fmt.pix;
+	rval = ioctl_try_fmt_cap(s, f);
+	if (rval)
+		return rval;
+	else
+		decoder->pix = *pix;
+
+	return rval;
+}
+
+/**
+ * ioctl_g_fmt_cap - V4L2 decoder interface handler for ioctl_g_fmt_cap
+ * @s: pointer to standard V4L2 device structure
+ * @f: pointer to standard V4L2 v4l2_format structure
+ *
+ * Returns the decoder's current pixel format in the v4l2_format
+ * parameter.
+ */
+static int
+ioctl_g_fmt_cap(struct v4l2_int_device *s, struct v4l2_format *f)
+{
+	struct tvp5146_decoder *decoder = s->priv;
+
+	if (f == NULL)
+		return -EINVAL;
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;	/* only capture is supported */
+
+	f->fmt.pix = decoder->pix;
+
+	return 0;
+}
+
+/**
+ * ioctl_g_parm - V4L2 decoder interface handler for VIDIOC_G_PARM ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @a: pointer to standard V4L2 VIDIOC_G_PARM ioctl structure
+ *
+ * Returns the decoder's video CAPTURE parameters.
+ */
+static int
+ioctl_g_parm(struct v4l2_int_device *s, struct v4l2_streamparm *a)
+{
+	struct tvp5146_decoder *decoder = s->priv;
+	struct v4l2_captureparm *cparm;
+	enum tvp5146_std current_std;
+
+	if (a == NULL)
+		return -EINVAL;
+
+	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;	/* only capture is supported */
+
+	memset(a, 0, sizeof(*a));
+	a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	/* get the current standard */
+	current_std = tvp5146_get_current_std(decoder);
+	decoder->current_std = current_std;
+
+	cparm = &a->parm.capture;
+	cparm->capability = V4L2_CAP_TIMEPERFRAME;
+	cparm->timeperframe
+	    = decoder->std_list[current_std].standard.frameperiod;
+
+	return 0;
+}
+
+/**
+ * ioctl_s_parm - V4L2 decoder interface handler for VIDIOC_S_PARM ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @a: pointer to standard V4L2 VIDIOC_S_PARM ioctl structure
+ *
+ * Configures the decoder to use the input parameters, if possible. If
+ * not possible, returns the appropriate error code.
+ */
+static int
+ioctl_s_parm(struct v4l2_int_device *s, struct v4l2_streamparm *a)
+{
+	struct tvp5146_decoder *decoder = s->priv;
+	struct v4l2_fract *timeperframe;
+	enum tvp5146_std current_std;
+
+	if (a == NULL)
+		return -EINVAL;
+
+	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;	/* only capture is supported */
+
+	timeperframe = &a->parm.capture.timeperframe;
+
+	/* get the current standard */
+	current_std = tvp5146_get_current_std(decoder);
+	decoder->current_std = current_std;
+
+	*timeperframe =
+	    decoder->std_list[current_std].standard.frameperiod;
+
+	return 0;
+}
+
+/**
+ * ioctl_g_ifparm - V4L2 decoder interface handler for vidioc_int_g_ifparm_num
+ * @s: pointer to standard V4L2 device structure
+ * @p: pointer to standard V4L2 vidioc_int_g_ifparm_num ioctl structure
+ *
+ * Gets slave interface parameters.
+ * Calculates the required xclk value to support the requested
+ * clock parameters in p. This value is returned in the p
+ * parameter.
+ */
+static int ioctl_g_ifparm(struct v4l2_int_device *s, struct v4l2_ifparm *p)
+{
+	struct tvp5146_decoder *decoder = s->priv;
+	int rval;
+
+	if (p == NULL)
+		return -EINVAL;
+
+	rval = decoder->pdata->ifparm(p);
+	if (rval) {
+		dev_err(&decoder->client->dev, "error. Err[%d]\n", rval);
+		return rval;
+	}
+
+	p->u.bt656.clock_curr = TVP5146_XCLK_BT656;
+
+	return 0;
+}
+
+/**
+ * ioctl_g_priv - V4L2 decoder interface handler for vidioc_int_g_priv_num
+ * @s: pointer to standard V4L2 device structure
+ * @p: void pointer to hold decoder's private data address
+ *
+ * Returns device's (decoder's) private data area address in p parameter
+ */
+static int ioctl_g_priv(struct v4l2_int_device *s, void *p)
+{
+	struct tvp5146_decoder *decoder = s->priv;
+
+	return decoder->pdata->priv_data_set(p);
+}
+
+/**
+ * ioctl_s_power - V4L2 decoder interface handler for vidioc_int_s_power_num
+ * @s: pointer to standard V4L2 device structure
+ * @on: power state to which device is to be set
+ *
+ * Sets devices power state to requrested state, if possible.
+ */
+static int ioctl_s_power(struct v4l2_int_device *s, enum v4l2_power on)
+{
+	struct tvp5146_decoder *decoder = s->priv;
+	int err = 0;
+
+	switch (on) {
+	case V4L2_POWER_OFF:
+		/* Power Down Sequence */
+		err =
+		    tvp5146_write_reg(decoder->client, REG_OPERATION_MODE,
+					0x01);
+		/* Disable mux for TVP5146 decoder data path */
+		err |= decoder->pdata->power_set(on);
+		break;
+
+	case V4L2_POWER_STANDBY:
+		err = decoder->pdata->power_set(on);
+		break;
+
+	case V4L2_POWER_ON:
+		/* Enable mux for TVP5146 decoder data path */
+		err = decoder->pdata->power_set(on);
+
+		/* Power Up Sequence */
+		err |=
+		    tvp5146_write_reg(decoder->client, REG_OPERATION_MODE,
+					0x01);
+		err |=
+		    tvp5146_write_reg(decoder->client, REG_OPERATION_MODE,
+					0x00);
+
+		/* Detect the sensor is not already detected */
+		if (decoder->state == STATE_NOT_DETECTED) {
+			err |= tvp5146_detect(decoder);
+			if (err < 0) {
+				dev_err(&decoder->client->dev,
+					"Unable to detect decoder\n");
+				return err;
+			}
+			dev_info(&decoder->client->dev,
+				 "chip version 0x%.2x detected\n",
+				 decoder->ver);
+		}
+		break;
+
+	case V4L2_POWER_RESUME:
+		err = decoder->pdata->power_set(on);
+		if (decoder->state == STATE_DETECTED)
+			err |= tvp5146_configure(decoder);
+		break;
+
+	default:
+		return -ENODEV;
+		break;
+	}
+
+	return err;
+}
+
+/**
+ * ioctl_init - V4L2 decoder interface handler for VIDIOC_INT_INIT
+ * @s: pointer to standard V4L2 device structure
+ *
+ * Initialize the decoder device (calls tvp5146_configure())
+ */
+static int ioctl_init(struct v4l2_int_device *s)
+{
+	struct tvp5146_decoder *decoder = s->priv;
+
+	/* Set default standard to auto */
+	decoder->pdata->reg_list[REG_VIDEO_STD].val =
+	    VIDEO_STD_AUTO_SWITCH_BIT;
+
+	return tvp5146_configure(decoder);
+}
+
+/**
+ * ioctl_dev_exit - V4L2 decoder interface handler for vidioc_int_dev_exit_num
+ * @s: pointer to standard V4L2 device structure
+ *
+ * Delinitialise the dev. at slave detach. The complement of ioctl_dev_init.
+ */
+static int ioctl_dev_exit(struct v4l2_int_device *s)
+{
+	return 0;
+}
+
+/**
+ * ioctl_dev_init - V4L2 decoder interface handler for vidioc_int_dev_init_num
+ * @s: pointer to standard V4L2 device structure
+ *
+ * Initialise the device when slave attaches to the master. Returns 0 if
+ * tvp5146 device could be found, otherwise returns appropriate error.
+ */
+static int ioctl_dev_init(struct v4l2_int_device *s)
+{
+	struct tvp5146_decoder *decoder = s->priv;
+	int err;
+
+	err = tvp5146_detect(decoder);
+	if (err < 0) {
+		dev_err(&decoder->client->dev,
+			"Unable to detect decoder\n");
+		return err;
+	}
+
+	dev_info(&decoder->client->dev,
+		 "chip version 0x%.2x detected\n", decoder->ver);
+
+	return 0;
+}
+
+static struct v4l2_int_ioctl_desc tvp5146_ioctl_desc[] = {
+	{vidioc_int_dev_init_num, (v4l2_int_ioctl_func*) ioctl_dev_init},
+	{vidioc_int_dev_exit_num, (v4l2_int_ioctl_func*) ioctl_dev_exit},
+	{vidioc_int_s_power_num, (v4l2_int_ioctl_func*) ioctl_s_power},
+	{vidioc_int_g_priv_num, (v4l2_int_ioctl_func*) ioctl_g_priv},
+	{vidioc_int_g_ifparm_num, (v4l2_int_ioctl_func*) ioctl_g_ifparm},
+	{vidioc_int_init_num, (v4l2_int_ioctl_func*) ioctl_init},
+	{vidioc_int_enum_fmt_cap_num,
+	 (v4l2_int_ioctl_func *) ioctl_enum_fmt_cap},
+	{vidioc_int_try_fmt_cap_num,
+	 (v4l2_int_ioctl_func *) ioctl_try_fmt_cap},
+	{vidioc_int_g_fmt_cap_num,
+	 (v4l2_int_ioctl_func *) ioctl_g_fmt_cap},
+	{vidioc_int_s_fmt_cap_num,
+	 (v4l2_int_ioctl_func *) ioctl_s_fmt_cap},
+	{vidioc_int_g_parm_num, (v4l2_int_ioctl_func *) ioctl_g_parm},
+	{vidioc_int_s_parm_num, (v4l2_int_ioctl_func *) ioctl_s_parm},
+	{vidioc_int_queryctrl_num,
+	 (v4l2_int_ioctl_func *) ioctl_queryctrl},
+	{vidioc_int_g_ctrl_num, (v4l2_int_ioctl_func *) ioctl_g_ctrl},
+	{vidioc_int_s_ctrl_num, (v4l2_int_ioctl_func *) ioctl_s_ctrl},
+	{vidioc_int_querystd_num, (v4l2_int_ioctl_func *) ioctl_querystd},
+	{vidioc_int_s_std_num, (v4l2_int_ioctl_func *) ioctl_s_std},
+	{vidioc_int_enum_input_num,
+	 (v4l2_int_ioctl_func *) ioctl_enum_input},
+	{vidioc_int_g_input_num, (v4l2_int_ioctl_func *) ioctl_g_input},
+	{vidioc_int_s_input_num, (v4l2_int_ioctl_func *) ioctl_s_input},
+};
+
+static struct v4l2_int_slave tvp5146_slave = {
+	.ioctls = tvp5146_ioctl_desc,
+	.num_ioctls = ARRAY_SIZE(tvp5146_ioctl_desc),
+};
+
+static struct tvp5146_decoder tvp5146_dev = {
+	.state = STATE_NOT_DETECTED,
+
+	.num_fmts = TVP5146_NUM_FORMATS,
+	.fmt_list = tvp5146_fmt_list,
+
+	.pix = {		/* Default to NTSC 8-bit YUV 422 */
+		.width = NTSC_NUM_ACTIVE_PIXELS,
+		.height = NTSC_NUM_ACTIVE_LINES,
+		.pixelformat = V4L2_PIX_FMT_UYVY,
+		.field = V4L2_FIELD_INTERLACED,
+		.bytesperline = NTSC_NUM_ACTIVE_PIXELS * 2,
+		.sizeimage =
+		NTSC_NUM_ACTIVE_PIXELS * 2 * NTSC_NUM_ACTIVE_LINES,
+		.colorspace = V4L2_COLORSPACE_SMPTE170M,
+		},
+
+	.current_std = STD_NTSC_MJ,
+	.num_stds = TVP5146_NUM_STANDARDS,
+	.std_list = tvp5146_std_list,
+
+	.num_ctrls = TVP5146_NUM_CONTROLS,
+	.ctrl_list = tvp5146_ctrl_list,
+
+	.inputidx = 0,		/* Composite selected */
+};
+
+static struct v4l2_int_device tvp5146_int_device = {
+	.module = THIS_MODULE,
+	.name = MODULE_NAME,
+	.priv = &tvp5146_dev,
+	.type = v4l2_int_type_slave,
+	.u = {
+	      .slave = &tvp5146_slave,
+	      },
+};
+
+/**
+ * tvp5146_probe - decoder driver i2c probe handler
+ * @client: i2c driver client device structure
+ *
+ * Register decoder as an i2c client device and V4L2
+ * device.
+ */
+static int
+tvp5146_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct tvp5146_decoder *decoder = &tvp5146_dev;
+	int err;
+
+	if (i2c_get_clientdata(client))
+		return -EBUSY;
+
+	decoder->pdata = client->dev.platform_data;
+	if (!decoder->pdata) {
+		dev_err(&client->dev, "No platform data\n!!");
+		return -ENODEV;
+	}
+
+	decoder->v4l2_int_device = &tvp5146_int_device;
+	decoder->client = client;
+	i2c_set_clientdata(client, decoder);
+
+	/* Register with V4L2 layer as slave device */
+	err = v4l2_int_device_register(decoder->v4l2_int_device);
+	if (err) {
+		i2c_set_clientdata(client, NULL);
+		dev_err(&client->dev,
+			"Unable to register to v4l2. Err[%d]\n", err);
+
+	} else
+		dev_info(&client->dev, "Registered to v4l2 done!!\n");
+
+	return 0;
+}
+
+/**
+ * tvp5146_remove - decoder driver i2c remove handler
+ * @client: i2c driver client device structure
+ *
+ * Unregister decoder as an i2c client device and V4L2
+ * device. Complement of tvp5146_probe().
+ */
+static int __exit tvp5146_remove(struct i2c_client *client)
+{
+	struct tvp5146_decoder *decoder = i2c_get_clientdata(client);
+
+	if (!client->adapter)
+		return -ENODEV;	/* our client isn't attached */
+
+	v4l2_int_device_unregister(decoder->v4l2_int_device);
+	i2c_set_clientdata(client, NULL);
+
+	return 0;
+}
+
+static const struct i2c_device_id tvp5146_id[] = {
+	{MODULE_NAME, 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, tvp5146_id);
+
+static struct i2c_driver tvp5146_i2c_driver = {
+	.driver = {
+		   .name = MODULE_NAME,
+		   .owner = THIS_MODULE,
+		   },
+	.probe = tvp5146_probe,
+	.remove = __exit_p(tvp5146_remove),
+	.id_table = tvp5146_id,
+};
+
+/**
+ * tvp5146_init
+ *
+ * Module init function
+ */
+static int __init tvp5146_init(void)
+{
+	int err;
+
+	err = i2c_add_driver(&tvp5146_i2c_driver);
+	if (err) {
+		printk(KERN_ERR "Failed to register " MODULE_NAME ".\n");
+		return err;
+	}
+	return 0;
+}
+
+/**
+ * tvp5146_cleanup
+ *
+ * Module exit function
+ */
+static void __exit tvp5146_cleanup(void)
+{
+	i2c_del_driver(&tvp5146_i2c_driver);
+}
+
+late_initcall(tvp5146_init);
+module_exit(tvp5146_cleanup);
+
+MODULE_AUTHOR("Texas Instruments");
+MODULE_DESCRIPTION("TVP5146 linux decoder driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/tvp5146.h b/drivers/media/video/tvp5146.h
new file mode 100644
index 0000000..ac26fa8
--- /dev/null
+++ b/drivers/media/video/tvp5146.h
@@ -0,0 +1,404 @@
+/*
+ * drivers/media/video/tvp5146.h
+ *
+ * Copyright (C) 2008 Texas Instruments Inc
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef _TVP5146_H
+#define _TVP5146_H
+
+/*
+ * TVP5146 registers
+ */
+#define REG_INPUT_SEL			(0x00)
+#define REG_AFE_GAIN_CTRL		(0x01)
+#define REG_VIDEO_STD			(0x02)
+#define REG_OPERATION_MODE		(0x03)
+#define REG_AUTOSWITCH_MASK		(0x04)
+
+#define REG_COLOR_KILLER		(0x05)
+#define REG_LUMA_CONTROL1		(0x06)
+#define REG_LUMA_CONTROL2		(0x07)
+#define REG_LUMA_CONTROL3		(0x08)
+
+#define REG_BRIGHTNESS			(0x09)
+#define REG_CONTRAST			(0x0A)
+#define REG_SATURATION			(0x0B)
+#define REG_HUE				(0x0C)
+
+#define REG_CHROMA_CONTROL1		(0x0D)
+#define REG_CHROMA_CONTROL2		(0x0E)
+
+/* 0x0F Reserved */
+
+#define REG_COMP_PR_SATURATION		(0x10)
+#define REG_COMP_Y_CONTRAST		(0x11)
+#define REG_COMP_PB_SATURATION		(0x12)
+
+/* 0x13 Reserved */
+
+#define REG_COMP_Y_BRIGHTNESS		(0x14)
+
+/* 0x15 Reserved */
+
+#define REG_AVID_START_PIXEL_LSB	(0x16)
+#define REG_AVID_START_PIXEL_MSB	(0x17)
+#define REG_AVID_STOP_PIXEL_LSB		(0x18)
+#define REG_AVID_STOP_PIXEL_MSB		(0x19)
+
+#define REG_HSYNC_START_PIXEL_LSB	(0x1A)
+#define REG_HSYNC_START_PIXEL_MSB	(0x1B)
+#define REG_HSYNC_STOP_PIXEL_LSB	(0x1C)
+#define REG_HSYNC_STOP_PIXEL_MSB	(0x1D)
+
+#define REG_VSYNC_START_LINE_LSB	(0x1E)
+#define REG_VSYNC_START_LINE_MSB	(0x1F)
+#define REG_VSYNC_STOP_LINE_LSB		(0x20)
+#define REG_VSYNC_STOP_LINE_MSB		(0x21)
+
+#define REG_VBLK_START_LINE_LSB		(0x22)
+#define REG_VBLK_START_LINE_MSB		(0x23)
+#define REG_VBLK_STOP_LINE_LSB		(0x24)
+#define REG_VBLK_STOP_LINE_MSB		(0x25)
+
+/* 0x26 - 0x27 Reserved */
+
+#define REG_FAST_SWTICH_CONTROL		(0x28)
+
+/* 0x29 Reserved */
+
+#define REG_FAST_SWTICH_SCART_DELAY	(0x2A)
+
+/* 0x2B Reserved */
+
+#define REG_SCART_DELAY			(0x2C)
+#define REG_CTI_DELAY			(0x2D)
+#define REG_CTI_CONTROL			(0x2E)
+
+/* 0x2F - 0x31 Reserved */
+
+#define REG_SYNC_CONTROL		(0x32)
+#define REG_OUTPUT_FORMATTER1		(0x33)
+#define REG_OUTPUT_FORMATTER2		(0x34)
+#define REG_OUTPUT_FORMATTER3		(0x35)
+#define REG_OUTPUT_FORMATTER4		(0x36)
+#define REG_OUTPUT_FORMATTER5		(0x37)
+#define REG_OUTPUT_FORMATTER6		(0x38)
+#define REG_CLEAR_LOST_LOCK		(0x39)
+
+#define REG_STATUS1			(0x3A)
+#define REG_STATUS2			(0x3B)
+
+#define REG_AGC_GAIN_STATUS_LSB		(0x3C)
+#define REG_AGC_GAIN_STATUS_MSB		(0x3D)
+
+/* 0x3E Reserved */
+
+#define REG_VIDEO_STD_STATUS		(0x3F)
+#define REG_GPIO_INPUT1			(0x40)
+#define REG_GPIO_INPUT2			(0x41)
+
+/* 0x42 - 0x45 Reserved */
+
+#define REG_AFE_COARSE_GAIN_CH1		(0x46)
+#define REG_AFE_COARSE_GAIN_CH2		(0x47)
+#define REG_AFE_COARSE_GAIN_CH3		(0x48)
+#define REG_AFE_COARSE_GAIN_CH4		(0x49)
+
+#define REG_AFE_FINE_GAIN_PB_B_LSB	(0x4A)
+#define REG_AFE_FINE_GAIN_PB_B_MSB	(0x4B)
+#define REG_AFE_FINE_GAIN_Y_G_CHROMA_LSB	(0x4C)
+#define REG_AFE_FINE_GAIN_Y_G_CHROMA_MSB	(0x4D)
+#define REG_AFE_FINE_GAIN_PR_R_LSB	(0x4E)
+#define REG_AFE_FINE_GAIN_PR_R_MSB	(0x4F)
+#define REG_AFE_FINE_GAIN_CVBS_LUMA_LSB	(0x50)
+#define REG_AFE_FINE_GAIN_CVBS_LUMA_MSB	(0x51)
+
+/* 0x52 - 0x68 Reserved */
+
+#define REG_FBIT_VBIT_CONTROL1		(0x69)
+
+/* 0x6A - 0x6B Reserved */
+
+#define REG_BACKEND_AGC_CONTROL		(0x6C)
+
+/* 0x6D - 0x6E Reserved */
+
+#define REG_AGC_DECREMENT_SPEED_CONTROL	(0x6F)
+#define REG_ROM_VERSION			(0x70)
+
+/* 0x71 - 0x73 Reserved */
+
+#define REG_AGC_WHITE_PEAK_PROCESSING	(0x74)
+#define REG_FBIT_VBIT_CONTROL2		(0x75)
+#define REG_VCR_TRICK_MODE_CONTROL	(0x76)
+#define REG_HORIZONTAL_SHAKE_INCREMENT	(0x77)
+#define REG_AGC_INCREMENT_SPEED		(0x78)
+#define REG_AGC_INCREMENT_DELAY		(0x79)
+
+/* 0x7A - 0x7F Reserved */
+
+#define REG_CHIP_ID_MSB			(0x80)
+#define REG_CHIP_ID_LSB			(0x81)
+
+/* 0x82 Reserved */
+
+#define REG_CPLL_SPEED_CONTROL		(0x83)
+
+/* 0x84 - 0x96 Reserved */
+
+#define REG_STATUS_REQUEST		(0x97)
+
+/* 0x98 - 0x99 Reserved */
+
+#define REG_VERTICAL_LINE_COUNT_LSB	(0x9A)
+#define REG_VERTICAL_LINE_COUNT_MSB	(0x9B)
+
+/* 0x9C - 0x9D Reserved */
+
+#define REG_AGC_DECREMENT_DELAY		(0x9E)
+
+/* 0x9F - 0xB0 Reserved */
+
+#define REG_VDP_TTX_FILTER_1_MASK1	(0xB1)
+#define REG_VDP_TTX_FILTER_1_MASK2	(0xB2)
+#define REG_VDP_TTX_FILTER_1_MASK3	(0xB3)
+#define REG_VDP_TTX_FILTER_1_MASK4	(0xB4)
+#define REG_VDP_TTX_FILTER_1_MASK5	(0xB5)
+#define REG_VDP_TTX_FILTER_2_MASK1	(0xB6)
+#define REG_VDP_TTX_FILTER_2_MASK2	(0xB7)
+#define REG_VDP_TTX_FILTER_2_MASK3	(0xB8)
+#define REG_VDP_TTX_FILTER_2_MASK4	(0xB9)
+#define REG_VDP_TTX_FILTER_2_MASK5	(0xBA)
+#define REG_VDP_TTX_FILTER_CONTROL	(0xBB)
+#define REG_VDP_FIFO_WORD_COUNT		(0xBC)
+#define REG_VDP_FIFO_INTERRUPT_THRLD	(0xBD)
+
+/* 0xBE Reserved */
+
+#define REG_VDP_FIFO_RESET		(0xBF)
+#define REG_VDP_FIFO_OUTPUT_CONTROL	(0xC0)
+#define REG_VDP_LINE_NUMBER_INTERRUPT	(0xC1)
+#define REG_VDP_PIXEL_ALIGNMENT_LSB	(0xC2)
+#define REG_VDP_PIXEL_ALIGNMENT_MSB	(0xC3)
+
+/* 0xC4 - 0xD5 Reserved */
+
+#define REG_VDP_LINE_START		(0xD6)
+#define REG_VDP_LINE_STOP		(0xD7)
+#define REG_VDP_GLOBAL_LINE_MODE	(0xD8)
+#define REG_VDP_FULL_FIELD_ENABLE	(0xD9)
+#define REG_VDP_FULL_FIELD_MODE		(0xDA)
+
+/* 0xDB - 0xDF Reserved */
+
+#define REG_VBUS_DATA_ACCESS_NO_VBUS_ADDR_INCR	(0xE0)
+#define REG_VBUS_DATA_ACCESS_VBUS_ADDR_INCR	(0xE1)
+#define REG_FIFO_READ_DATA			(0xE2)
+
+/* 0xE3 - 0xE7 Reserved */
+
+#define REG_VBUS_ADDRESS_ACCESS1	(0xE8)
+#define REG_VBUS_ADDRESS_ACCESS2	(0xE9)
+#define REG_VBUS_ADDRESS_ACCESS3	(0xEA)
+
+/* 0xEB - 0xEF Reserved */
+
+#define REG_INTERRUPT_RAW_STATUS0	(0xF0)
+#define REG_INTERRUPT_RAW_STATUS1	(0xF1)
+#define REG_INTERRUPT_STATUS0		(0xF2)
+#define REG_INTERRUPT_STATUS1		(0xF3)
+#define REG_INTERRUPT_MASK0		(0xF4)
+#define REG_INTERRUPT_MASK1		(0xF5)
+#define REG_INTERRUPT_CLEAR0		(0xF6)
+#define REG_INTERRUPT_CLEAR1		(0xF7)
+
+/* 0xF8 - 0xFF Reserved */
+
+/*
+ * Mask and bit definitions of TVP5146 registers
+ */
+/* The ID values we are looking for */
+#define TVP5146_CHIP_ID_MSB		(0x51)
+#define TVP5146_CHIP_ID_LSB		(0x46)
+
+#define VIDEO_STD_MASK			(0x07)
+#define VIDEO_STD_AUTO_SWITCH_BIT	(0x00)
+#define VIDEO_STD_NTSC_MJ_BIT		(0x01)
+#define VIDEO_STD_PAL_BDGHIN_BIT	(0x02)
+#define VIDEO_STD_PAL_M_BIT		(0x03)
+#define VIDEO_STD_PAL_COMBINATION_N_BIT	(0x04)
+#define VIDEO_STD_NTSC_4_43_BIT		(0x05)
+#define VIDEO_STD_SECAM_BIT		(0x06)
+#define VIDEO_STD_PAL_60_BIT		(0x07)
+
+/*
+ * Other macros
+ */
+#define TVP5146_MODULE_NAME		"tvp5146"
+#define TVP5146_I2C_DELAY		(3)
+#define I2C_RETRY_COUNT			(5)
+#define LOCK_RETRY_COUNT		(3)
+#define LOCK_RETRY_DELAY		(200)
+
+#define TOK_WRITE			(0)	/* token for write operation */
+#define TOK_TERM			(1)	/* terminating token */
+#define TOK_DELAY			(2)	/* delay token for reg list */
+#define TOK_SKIP			(3)	/* token to skip a register */
+
+#define TVP5146_XCLK_BT656		(27000000)
+
+/* Number of pixels and number of lines per frame for different standards */
+#define NTSC_NUM_ACTIVE_PIXELS		(720)
+#define NTSC_NUM_ACTIVE_LINES		(480)
+#define PAL_NUM_ACTIVE_PIXELS		(720)
+#define PAL_NUM_ACTIVE_LINES		(576)
+
+/**
+ * enum tvp5146_std - enum for supported standards
+ */
+enum tvp5146_std {
+	STD_NTSC_MJ = 0,
+	STD_PAL_BDGHIN,
+	STD_INVALID
+};
+
+/**
+ * enum tvp5146_state - enum for different decoder states
+ */
+enum tvp5146_state {
+	STATE_NOT_DETECTED,
+	STATE_DETECTED
+};
+
+/**
+ * struct tvp5146_reg - Structure for TVP5146 register initialization values
+ * @token - Token: TOK_WRITE, TOK_TERM etc..
+ * @reg - Register offset
+ * @val - Register Value for TOK_WRITE or delay in ms for TOK_DELAY
+ */
+struct tvp5146_reg {
+	u8 token;
+	u8 reg;
+	u32 val;
+};
+
+/**
+ * struct tvp5146_std_info - Structure to store standard informations
+ * @width: Line width in pixels
+ * @height:Number of active lines
+ * @video_std: Value to write in REG_VIDEO_STD register
+ * @standard: v4l2 standard structure information
+ */
+struct tvp5146_std_info {
+	unsigned long width;
+	unsigned long height;
+	u8 video_std;
+	struct v4l2_standard standard;
+};
+
+/**
+ * struct tvp5146_ctrl_info - Information regarding supported controls
+ * @reg_address: Register offset of control register
+ * @query_ctrl: v4l2 query control information
+ */
+struct tvp5146_ctrl_info {
+	u8 reg_address;
+	struct v4l2_queryctrl query_ctrl;
+};
+
+/**
+ * struct tvp5146_input_info - Information regarding supported inputs
+ * @input_sel: Input select register
+ * @lock_mask: lock mask - depends on Svideo/CVBS
+ * @input: v4l2 input information
+ */
+struct tvp5146_input_info {
+	u8 input_sel;
+	u8 lock_mask;
+	struct v4l2_input input;
+};
+
+/**
+ * struct tvp5146_platform_data - Platform data values and access functions
+ * @power_set: Power state access function, zero is off, non-zero is on.
+ * @ifparm: Interface parameters access function
+ * @priv_data_set: Device private data (pointer) access function
+ * @reg_list: The board dependent driver should fill the default value for
+ *            required registers depending on board layout. The TVP5146
+ *            driver will update this register list for the registers
+ *            whose values should be maintained across open()/close() like
+ *            setting brightness as defined in V4L2.
+ *            The register list should be in the same order as defined in
+ *            TVP5146 datasheet including reserved registers. As of now
+ *            the driver expects the size of this list to be a minimum of
+ *            57 + 1 (upto regsiter REG_CLEAR_LOST_LOCK).
+ *            The last member should be of the list should be
+ *            {TOK_TERM, 0, 0} to indicate the end of register list.
+ * @num_inputs: Number of input connection in board
+ * @input_list: Input information list for num_inputs
+ */
+struct tvp5146_platform_data {
+	int (*power_set) (enum v4l2_power on);
+	int (*ifparm) (struct v4l2_ifparm *p);
+	int (*priv_data_set) (void *);
+
+	struct tvp5146_reg *reg_list;
+
+	int num_inputs;
+	const struct tvp5146_input_info *input_list;
+};
+
+/**
+ * struct tvp5146_decoded - TVP5146 decoder object
+ * @v4l2_int_device: Slave handle
+ * @pdata: Board specific
+ * @client: I2C client data
+ * @ver: Chip version
+ * @state: TVP5146 decoder state - detected or not-detected
+ * @pix: Current pixel format
+ * @num_fmts: Number of formats
+ * @fmt_list: Format list
+ * @current_std: Current standard
+ * @num_stds: Number of standards
+ * @std_list: Standards list
+ * @num_ctrls: Number of controls
+ * @ctrl_list: Control list
+ */
+struct tvp5146_decoder {
+	struct v4l2_int_device *v4l2_int_device;
+	const struct tvp5146_platform_data *pdata;
+	struct i2c_client *client;
+
+	int ver;
+	enum tvp5146_state state;
+
+	struct v4l2_pix_format pix;
+	int num_fmts;
+	const struct v4l2_fmtdesc *fmt_list;
+
+	enum tvp5146_std current_std;
+	int num_stds;
+	struct tvp5146_std_info *std_list;
+
+	int num_ctrls;
+	const struct tvp5146_ctrl_info *ctrl_list;
+
+	int inputidx;
+};
+
+#endif				/* ifndef _TVP5146_H */
diff --git a/drivers/media/video/v4l2-int-device.c b/drivers/media/video/v4l2-int-device.c
index 0e45499..a935bae 100644
--- a/drivers/media/video/v4l2-int-device.c
+++ b/drivers/media/video/v4l2-int-device.c
@@ -32,7 +32,7 @@
 static DEFINE_MUTEX(mutex);
 static LIST_HEAD(int_list);
 
-static void v4l2_int_device_try_attach_all(void)
+void v4l2_int_device_try_attach_all(void)
 {
 	struct v4l2_int_device *m, *s;
 
@@ -66,6 +66,7 @@ static void v4l2_int_device_try_attach_all(void)
 		}
 	}
 }
+EXPORT_SYMBOL_GPL(v4l2_int_device_try_attach_all);
 
 static int ioctl_sort_cmp(const void *a, const void *b)
 {
@@ -144,6 +145,7 @@ int v4l2_int_ioctl_0(struct v4l2_int_device *d, int cmd)
 		find_ioctl(d->u.slave, cmd,
 			   (v4l2_int_ioctl_func *)no_such_ioctl_0))(d);
 }
+EXPORT_SYMBOL_GPL(v4l2_int_ioctl_0);
 
 static int no_such_ioctl_1(struct v4l2_int_device *d, void *arg)
 {
@@ -156,5 +158,6 @@ int v4l2_int_ioctl_1(struct v4l2_int_device *d, int cmd, void *arg)
 		find_ioctl(d->u.slave, cmd,
 			   (v4l2_int_ioctl_func *)no_such_ioctl_1))(d, arg);
 }
+EXPORT_SYMBOL_GPL(v4l2_int_ioctl_1);
 
 MODULE_LICENSE("GPL");
diff --git a/include/asm-arm/arch-omap/isp_user.h b/include/asm-arm/arch-omap/isp_user.h
index b70da06..1636fd5 100644
--- a/include/asm-arm/arch-omap/isp_user.h
+++ b/include/asm-arm/arch-omap/isp_user.h
@@ -141,6 +141,120 @@ struct isp_hist_data {
 	u32 *hist_statistics_buf;	/* Pointer to pass to user */
 };
 
+/* Auto Focus related structs */
+
+#define AF_NUMBER_OF_COEF		11
+
+/* Flags for update field */
+#define REQUEST_STATISTICS		(1 << 0)
+#define LENS_DESIRED_POSITION	(1 << 1)
+#define LENS_CURRENT_POSITION	(1 << 2)
+
+/**
+ * struct isp_af_xtrastats - Extra statistics related to AF generated stats.
+ * @ts: Timestamp when the frame gets delivered to the user.
+ * @field_count: Field count of the frame delivered to the user.
+ * @lens_position: Lens position when the stats are being generated.
+ */
+struct isp_af_xtrastats {
+	struct timeval ts;
+	unsigned long field_count;
+	__u16 lens_position;
+};
+
+/**
+ * struct isp_af_data - AF statistics data to transfer between driver and user.
+ * @af_statistics_buf: Pointer to pass to user.
+ * @lens_current_position: Read value of lens absolute position.
+ * @desired_lens_direction: Lens desired location.
+ * @update: Bitwise flags to update parameters.
+ * @frame_number: Data for which frame is desired/given.
+ * @curr_frame: Current frame number being processed by AF module.
+ * @xtrastats: Extra statistics structure.
+ */
+struct isp_af_data {
+	void *af_statistics_buf;
+	__u16 lens_current_position;
+	__u16 desired_lens_direction;
+	__u16 update;
+	__u16 frame_number;
+	__u16 curr_frame;
+	struct isp_af_xtrastats xtrastats;
+};
+
+/* enum used for status of specific feature */
+enum af_alaw_enable {
+	H3A_AF_ALAW_DISABLE = 0,
+	H3A_AF_ALAW_ENABLE = 1
+};
+
+enum af_hmf_enable {
+	H3A_AF_HMF_DISABLE = 0,
+	H3A_AF_HMF_ENABLE = 1
+};
+
+enum af_config_flag {
+	H3A_AF_CFG_DISABLE = 0,
+	H3A_AF_CFG_ENABLE = 1
+};
+
+enum af_mode {
+	ACCUMULATOR_SUMMED = 0,
+	ACCUMULATOR_PEAK = 1
+};
+
+/* Red, Green, and blue pixel location in the AF windows */
+enum rgbpos {
+	GR_GB_BAYER = 0,	/* GR and GB as Bayer pattern */
+	RG_GB_BAYER = 1,	/* RG and GB as Bayer pattern */
+	GR_BG_BAYER = 2,	/* GR and BG as Bayer pattern */
+	RG_BG_BAYER = 3,	/* RG and BG as Bayer pattern */
+	GG_RB_CUSTOM = 4,	/* GG and RB as custom pattern */
+	RB_GG_CUSTOM = 5	/* RB and GG as custom pattern */
+};
+
+/* Contains the information regarding the Horizontal Median Filter */
+struct af_hmf {
+	enum af_hmf_enable enable;	/* Status of Horizontal Median Filter */
+	unsigned int threshold;	/* Threshhold Value for Horizontal Median
+				 * Filter
+				 */
+};
+
+/* Contains the information regarding the IIR Filters */
+struct af_iir {
+	unsigned int hz_start_pos;	/* IIR Start Register Value */
+	int coeff_set0[AF_NUMBER_OF_COEF];	/*
+						 * IIR Filter Coefficient for
+						 * Set 0
+						 */
+	int coeff_set1[AF_NUMBER_OF_COEF];	/*
+						 * IIR Filter Coefficient for
+						 * Set 1
+						 */
+};
+
+/* Contains the information regarding the Paxels Structure in AF Engine */
+struct af_paxel {
+	unsigned int width;	/* Width of the Paxel */
+	unsigned int height;	/* Height of the Paxel */
+	unsigned int hz_start;	/* Horizontal Start Position */
+	unsigned int vt_start;	/* Vertical Start Position */
+	unsigned int hz_cnt;	/* Horizontal Count */
+	unsigned int vt_cnt;	/* vertical Count */
+	unsigned int line_incr;	/* Line Increment */
+};
+/* Contains the parameters required for hardware set up of AF Engine */
+struct af_configuration {
+	enum af_alaw_enable alaw_enable;	/*ALWAW status */
+	struct af_hmf hmf_config;	/*HMF configurations */
+	enum rgbpos rgb_pos;		/*RGB Positions */
+	struct af_iir iir_config;	/*IIR filter configurations */
+	struct af_paxel paxel_config;	/*Paxel parameters */
+	enum af_mode mode;		/*Accumulator mode */
+	enum af_config_flag af_config; /*Flag indicates Engine is configured */
+};
+
 /* ISP CCDC structs */
 
 /* Abstraction layer CCDC configurations */
diff --git a/include/asm-arm/mach/map.h b/include/asm-arm/mach/map.h
index 7ef3c83..99db800 100644
--- a/include/asm-arm/mach/map.h
+++ b/include/asm-arm/mach/map.h
@@ -25,6 +25,7 @@ struct map_desc {
 #define MT_HIGH_VECTORS		7
 #define MT_MEMORY		8
 #define MT_ROM			9
+#define MT_MEMORY_SO		10
 
 #define MT_NONSHARED_DEVICE	MT_DEVICE_NONSHARED
 #define MT_IXP2000_DEVICE	MT_DEVICE_IXP2000
diff --git a/include/media/v4l2-int-device.h b/include/media/v4l2-int-device.h
index 6795b32..8e423ea 100644
--- a/include/media/v4l2-int-device.h
+++ b/include/media/v4l2-int-device.h
@@ -84,6 +84,8 @@ struct v4l2_int_device {
 	void *priv;
 };
 
+void v4l2_int_device_try_attach_all(void);
+
 int v4l2_int_device_register(struct v4l2_int_device *d);
 void v4l2_int_device_unregister(struct v4l2_int_device *d);
 
@@ -283,6 +285,14 @@ enum v4l2_int_ioctl_num {
 	vidioc_int_s_crop_num,
 	vidioc_int_g_parm_num,
 	vidioc_int_s_parm_num,
+	vidioc_int_querystd_num,
+	vidioc_int_s_std_num,
+	vidioc_int_enum_input_num,
+	vidioc_int_g_input_num,
+	vidioc_int_s_input_num,
+	vidioc_int_enumoutput_num,
+	vidioc_int_g_output_num,
+	vidioc_int_s_output_num,
 
 	/*
 	 *
@@ -384,6 +394,14 @@ V4L2_INT_WRAPPER_1(g_crop, struct v4l2_crop, *);
 V4L2_INT_WRAPPER_1(s_crop, struct v4l2_crop, *);
 V4L2_INT_WRAPPER_1(g_parm, struct v4l2_streamparm, *);
 V4L2_INT_WRAPPER_1(s_parm, struct v4l2_streamparm, *);
+V4L2_INT_WRAPPER_1(querystd, v4l2_std_id, *);
+V4L2_INT_WRAPPER_1(s_std, v4l2_std_id, *);
+V4L2_INT_WRAPPER_1(enum_input, struct v4l2_input, *);
+V4L2_INT_WRAPPER_1(g_input, int, *);
+V4L2_INT_WRAPPER_1(s_input, int, );
+V4L2_INT_WRAPPER_1(enumoutput, struct v4l2_output, *);
+V4L2_INT_WRAPPER_1(g_output, int, *);
+V4L2_INT_WRAPPER_1(s_output, int, );
 
 V4L2_INT_WRAPPER_0(dev_init);
 V4L2_INT_WRAPPER_0(dev_exit);
-- 
1.5.6

